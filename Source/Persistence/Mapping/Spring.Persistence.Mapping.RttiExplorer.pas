{***************************************************************************}
{                                                                           }
{           Spring Framework for Delphi                                     }
{                                                                           }
{           Copyright (c) 2009-2014 Spring4D Team                           }
{                                                                           }
{           http://www.spring4d.org                                         }
{                                                                           }
{***************************************************************************}
{                                                                           }
{  Licensed under the Apache License, Version 2.0 (the "License");          }
{  you may not use this file except in compliance with the License.         }
{  You may obtain a copy of the License at                                  }
{                                                                           }
{      http://www.apache.org/licenses/LICENSE-2.0                           }
{                                                                           }
{  Unless required by applicable law or agreed to in writing, software      }
{  distributed under the License is distributed on an "AS IS" BASIS,        }
{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. }
{  See the License for the specific language governing permissions and      }
{  limitations under the License.                                           }
{                                                                           }
{***************************************************************************}

{$I Spring.inc}

unit Spring.Persistence.Mapping.RttiExplorer;

interface

uses
  Rtti,
  TypInfo,
  SysUtils,
  Spring.Collections,
  Spring.Persistence.Core.EntityCache,
  Spring.Persistence.Core.Interfaces,
  Spring.Persistence.Mapping.Attributes;

type
  TRttiCache = class
  private
    FFields: IDictionary<string,TRttiField>;
    FProperties: IDictionary<string,TRttiProperty>;
    FTypes: IDictionary<PTypeInfo,TRttiType>;
    FTypeFields: IDictionary<PTypeInfo,IList<TRttiField>>;
    FCtx: TRttiContext;
  protected
    function GetKey(AClass: TClass; const AName: string): string;
  public
    constructor Create; virtual;

    procedure Clear;
    procedure RebuildCache; virtual;

    function GetField(AClass: TClass; const AFieldName: string): TRttiField;
    function GetProperty(AClass: TClass; const APropertyName: string): TRttiProperty;
    function GetNamedObject(AClass: TClass; const AMemberName: string): TRttiNamedObject;
    function GetType(ATypeInfo: PTypeInfo): TRttiType; overload;
    function GetType(AClass: TClass): TRttiType; overload;
    function GetFieldsOfType(ATypeInfo: PTypeInfo): IList<TRttiField>;
  end;

  TRttiExplorer = class
  private
    class var FCtx: TRttiContext;
    class var FRttiCache: TRttiCache;
  protected
    class constructor Create;
    class destructor Destroy;
  public
    class function Clone(entity: TObject): TObject;
//    class function CreateNewClass<T>: T;
//    class function CreateNewInterface(AInterfaceTypeInfo, AClassTypeInfo: PTypeInfo): IInvokable; overload;
//    class function CreateNewInterface<TInterfaceType, TClassType>: TInterfaceType; overload;
//    class function CreateType(AClass: TClass): TObject; overload;
//    class function CreateType(ATypeInfo: PTypeInfo): TObject; overload;
    class function CreateExternalType(AClass: TClass; const Args: array of TValue): TObject;
    class function EntityChanged(AEntity1, AEntity2: TObject): Boolean;
    class function GetAttributeOfClass(ARttiObject: TRttiObject; AClass: TClass): TCustomAttribute; overload;
    class function GetAttributeOfClass<T: TCustomAttribute>(ARttiObject: TRttiObject): T; overload;
    class function GetAsRecord(ARttiObject: TRttiNamedObject): TRttiRecordType;
    class function GetAssociations(AClass: TClass): IList<Association>;
    class function GetAutoGeneratedColumnMemberName(AClass: TClass): string;
    class function GetChangedMembers(AOriginalObj, ADirtyObj: TObject): IList<ColumnAttribute>; overload;
    class function GetClassAttribute<T: TORMAttribute>(AClass: TClass; ARecursive: Boolean = False): T;
    class function GetColumns(AClass: TClass): IList<ColumnAttribute>; overload;
    class function GetColumnIsIdentity(AClass: TClass; AColumn: ColumnAttribute): Boolean;
    class procedure GetDeclaredConstructors(AClass: TClass; AList: IList<TRttiMethod>);
    class function GetMethodWithLessParameters(AList: IList<TRttiMethod>): TRttiMethod;
    class function GetEntities: IList<TClass>;
    class function GetEntityClass(classInfo: PTypeInfo): TClass;
    class function GetEntityRttiType(ATypeInfo: PTypeInfo): TRttiType; overload;
    class function GetEntityRttiType<T>: TRttiType; overload;
    class function HasInstanceField(AClass: TClass): Boolean;
    class function GetSubEntityFromMemberDeep(AEntity: TObject; ARttiMember: TRttiNamedObject): IList<TObject>;
    class function GetRelationsOf(AEntity: TObject): IList<TObject>;
    class function GetLastGenericArgumentType(ATypeInfo: PTypeInfo): TRttiType;
    class function GetForeignKeyColumn(AClass: TClass; const ABaseTablePrimaryKeyColumn: ColumnAttribute): ForeignJoinColumnAttribute;
    class function GetMemberValue(AEntity: TObject; const AMember: TRttiNamedObject): TValue; overload;
    class function GetMemberValue(AEntity: TObject; const AMemberName: string): TValue; overload;
    class function GetMemberValue(AEntity: TObject; const AMembername: string; out ARttiMember: TRttiNamedObject): TValue; overload;
    class function GetMemberValueDeep(AEntity: TObject; const AMemberName: string): TValue; overload;
    class function GetMemberValueDeep(const AInitialValue: TValue; ARttiType: TRttiType): TValue; overload;
    class function GetPrimaryKeyColumn(AClass: TClass): ColumnAttribute;
    class function GetPrimaryKeyColumnMemberName(AClass: TClass): string;
    class function GetPrimaryKeyColumnName(AClass: TClass): string;
    class function GetPrimaryKeyValue(AEntity: TObject): TValue;
    class function GetRawPointer(const AInstance: TValue): Pointer;
    class function GetRttiType(AEntity: TClass): TRttiType;
    class function GetSequence(AClass: TClass): SequenceAttribute;
    class function GetTable(AClass: TClass): TableAttribute; overload;
    class function GetTable(AClassInfo: PTypeInfo): TableAttribute; overload;
    class function GetClassFromClassInfo(AClassInfo: PTypeInfo): TClass;
    class function GetMemberTypeInfo(AClass: TClass; const AMemberName: string): PTypeInfo;
    class function GetUniqueConstraints(AClass: TClass): IList<UniqueConstraint>;
    class function HasSequence(AClass: TClass): Boolean;
    class function HasColumns(AClass: TClass): Boolean;
//    class function IsValidEntity(AClass: TClass): Boolean;
    class function TryGetColumnAsForeignKey(AColumn: ColumnAttribute; out AForeignKeyCol: ForeignJoinColumnAttribute): Boolean;
    class function TryGetBasicMethod(const AMethodName: string; ATypeInfo: PTypeInfo; out AMethod: TRttiMethod): Boolean;
//    class function TryGetColumnByMemberName(AClass: TClass; const AClassMemberName: string; out AColumn: ColumnAttribute): Boolean;
    class function TryGetPrimaryKeyValue(AColumns: IList<ColumnAttribute>; AResultset: IDBResultset; out AValue: TValue; out AColumn: ColumnAttribute): Boolean;
    class function TryGetMethod(ATypeInfo: PTypeInfo; const AMethodName: string; out AAddMethod: TRttiMethod; AParamCount: Integer = 1): Boolean;
    class procedure CopyFieldValues(const source, target: TObject);
//    class procedure DestroyClass<T>(var AObject: T);
    class procedure GetChangedMembers(AOriginalObj, ADirtyObj: TObject; AList: IList<ColumnAttribute>); overload;
    class function GetClassMembers<T: TORMAttribute>(AClass: TClass): IList<T>; overload;
    class procedure SetMemberValue(AEntity: TObject; const AMemberColumn: ColumnAttribute; const AValue: TValue); overload;
    class procedure SetMemberValue(AEntity: TObject; const AMemberName: string; const AValue: TValue); overload;
    class procedure SetMemberValueSimple(AEntity: TObject; const AMemberName: string; const AValue: TValue);
    class procedure SetValue(AInstance: Pointer; ANamedObject: TRttiNamedObject; const AValue: TValue);

    class function InheritsFrom(AObjectInfo: TClass; AFromObjectInfo: PTypeInfo): Boolean;
    class function GetNamedObject(AClass: TClass; const APropertyName: string): TRttiNamedObject;

    class function GetQueryTextFromMethod(AMethod: TRttiMethod): string;
    class function GetMethodSignature(AMethod: TRttiMethod): string;

    class property RttiCache: TRttiCache read FRttiCache;
  end;

implementation

uses
  Classes,
  Math,
  StrUtils,
  Spring.Persistence.Core.CollectionAdapterResolver,
  Spring.Persistence.Core.Exceptions,
  Spring.Persistence.Core.Reflection,
  Spring.Persistence.Core.Utils,
  Spring.Reflection, Spring.Helpers,
  Spring.Reflection.Activator;


{$REGION 'TRttiExplorer'}

class constructor TRttiExplorer.Create;
begin
  FRttiCache := TRttiCache.Create;
  FRttiCache.RebuildCache;
end;

class destructor TRttiExplorer.Destroy;
begin
  FRttiCache.Free;
end;

class function TRttiExplorer.Clone(entity: TObject): TObject;
begin
  Assert(Assigned(entity));
  Result := TActivator.CreateInstance(entity.ClassType);
  CopyFieldValues(entity, Result);
end;

class procedure TRttiExplorer.CopyFieldValues(const source, target: TObject);
var
  field: TRttiField;
  value: TValue;
  sourceObject, targetObject: TObject;
begin
  Assert(Assigned(source) and Assigned(target));
  Assert(source.ClassType = target.ClassType);

  for field in TType.GetType(source.ClassInfo).GetFields do
  begin
    if field.FieldType.IsInstance then
    begin
      sourceObject := field.GetValue(source).AsObject;
      if not Assigned(sourceObject) then
        Continue;
      targetObject := field.GetValue(target).AsObject;
      if not Assigned(targetObject) then
        targetObject := TActivator.CreateInstance(sourceObject.ClassType);
      if targetObject is TPersistent then
        TPersistent(targetObject).Assign(sourceObject as TPersistent)
      else
        CopyFieldValues(sourceObject, targetObject);
      value := targetObject;
    end
    else
      value := field.GetValue(source);
  
    field.SetValue(target, value);
  end;
end;

class function TRttiExplorer.CreateExternalType(AClass: TClass;
  const Args: array of TValue): TObject;
var
  LMethod: TRttiMethod;
  LType: TRttiType;
begin
  Result := nil;
  LType := TRttiContext.Create.GetType(AClass);
  for LMethod in LType.GetMethods do
  begin
    if (LMethod.IsConstructor) and (Length(LMethod.GetParameters) = Length(Args)) then
    begin
      Result := LMethod.Invoke(LType.AsInstance.MetaclassType, Args).AsObject;
      Break;
    end;
  end;
end;

//class function TRttiExplorer.CreateNewClass<T>: T;
//var
//  rType: TRttiType;
//  AMethCreate: TRttiMethod;
//  instanceType: TRttiInstanceType;
//begin
//  rType := FRttiCache.GetType(TypeInfo(T));// TRttiContext.Create.GetType(TypeInfo(T));
//  if rType.IsInstance then
//  begin
//    for AMethCreate in rType.GetMethods do
//    begin
//      if (AMethCreate.IsConstructor) and (Length(AMethCreate.GetParameters) = 0) then
//      begin
//        instanceType := rType.AsInstance;
//        Result := AMethCreate.Invoke(instanceType.MetaclassType, []).AsType<T>;
//        Break;
//      end;
//    end;
//  end;
//end;

//class function TRttiExplorer.CreateNewInterface(AInterfaceTypeInfo, AClassTypeInfo: PTypeInfo): IInvokable;
//var
//  rType: TRttiType;
//begin
//  rType := FRttiCache.GetType(AInterfaceTypeInfo);
//  if rType.IsInterface then
//  begin
//    Supports(TActivator.CreateInstance(AClassTypeInfo).AsObject, rType.AsInterface.GUID, Result);
//  end;
//end;
//
//class function TRttiExplorer.CreateNewInterface<TInterfaceType, TClassType>: TInterfaceType;
//var
//  rType: TRttiType;
//begin
//  rType := FRttiCache.GetType(TypeInfo(TInterfaceType));
//  if rType.IsInterface then
//  begin
//    Supports(TActivator.CreateInstance(TypeInfo(TClassType)), rType.AsInterface.GUID, Result);
//  end;
//end;

//class function TRttiExplorer.CreateType(ATypeInfo: PTypeInfo): TObject;
//var
//  rType: TRttiType;
//  AMethCreate: TRttiMethod;
//  instanceType: TRttiInstanceType;
//begin
//  rType := FRttiCache.GetType(ATypeInfo);
//  if rType.IsInstance then
//  begin
//    for AMethCreate in rType.GetMethods do
//    begin
//      if (AMethCreate.IsConstructor) and (Length(AMethCreate.GetParameters) = 0) then
//      begin
//        instanceType := rType.AsInstance;
//        Result := AMethCreate.Invoke(instanceType.MetaclassType, []).AsObject;
//        Exit;
//      end;
//    end;
//  end;
//  Result := nil;
//end;
//
//class function TRttiExplorer.CreateType(AClass: TClass): TObject;
//begin
//  Result := CreateType(AClass.ClassInfo);
//end;

//class procedure TRttiExplorer.DestroyClass<T>(var AObject: T);
//begin
//  if PTypeInfo(TypeInfo(T)).Kind = tkClass then
//    PObject(@AObject)^.Free;
//end;

class function TRttiExplorer.EntityChanged(AEntity1, AEntity2: TObject): Boolean;
var
  LChangedMembers: IList<ColumnAttribute>;
begin
  LChangedMembers := GetChangedMembers(AEntity1, AEntity2);
  Result := LChangedMembers.Any;
end;

class function TRttiExplorer.GetAsRecord(ARttiObject: TRttiNamedObject): TRttiRecordType;
begin
  Result := nil;
  if ARttiObject is TRttiProperty then
    Result := TRttiProperty(ARttiObject).PropertyType.AsRecord
  else if ARttiObject is TRttiField then
    Result := TRttiField(ARttiObject).FieldType.AsRecord;
end;

class function TRttiExplorer.GetAssociations(AClass: TClass): IList<Association>;
begin
  Result := GetClassMembers<Association>(AClass);
end;

class function TRttiExplorer.GetAttributeOfClass(ARttiObject: TRttiObject;
  AClass: TClass): TCustomAttribute;
begin
  for Result in ARttiObject.GetAttributes do
  begin
    if Result.InheritsFrom(AClass) then
    begin
      Exit;
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetAttributeOfClass<T>(
  ARttiObject: TRttiObject): T;
begin
  Result := T(GetAttributeOfClass(ARttiObject, TClass(T)));
end;

class function TRttiExplorer.GetAutoGeneratedColumnMemberName(AClass: TClass): string;
var
  LIds: IList<AutoGenerated>;
begin
  Result := '';

  LIds := GetClassMembers<AutoGenerated>(AClass);
  if LIds.Any then
  begin
    Result := LIds.First.MemberName;
  end;
end;

class function TRttiExplorer.GetChangedMembers(AOriginalObj, ADirtyObj: TObject): IList<ColumnAttribute>;
begin
  Result := TCollections.CreateList<ColumnAttribute>;
  GetChangedMembers(AOriginalObj, ADirtyObj, Result);
end;

class procedure TRttiExplorer.GetChangedMembers(AOriginalObj, ADirtyObj: TObject; AList: IList<ColumnAttribute>);
var
  LRttiType: TRttiType;
  LMember: TRttiMember;
  LOriginalValue, LDirtyValue: TValue;
  LCol: ColumnAttribute;
  LColumns: IList<ColumnAttribute>;
begin
  Assert(AOriginalObj.ClassType = ADirtyObj.ClassType);
  LRttiType := FRttiCache.GetType(AOriginalObj.ClassInfo);
  AList.Clear;

  LColumns := GetColumns(AOriginalObj.ClassType);
  for LCol in LColumns do
  begin
    if not LCol.IsDiscriminator then
    begin

      case LCol.MemberKind of
        mkField:    LMember := FRttiCache.GetField(LRttiType.AsInstance.MetaclassType, LCol.MemberName); // LRttiType.GetField(LCol.ClassMemberName);
        mkProperty: LMember := FRttiCache.GetProperty(LRttiType.AsInstance.MetaclassType, LCol.MemberName); // LRttiType.GetProperty(LCol.ClassMemberName);
      else
        LMember := nil;
      end;

      if not Assigned(LMember) then
        raise EUnknownMember.Create('Unknown column member: ' + LCol.MemberName);

      LOriginalValue := GetMemberValue(AOriginalObj, LMember);
      LDirtyValue := GetMemberValue(ADirtyObj, LMember);

      if not Spring.Persistence.Core.Reflection.SameValue(LOriginalValue, LDirtyValue) then
        AList.Add(LCol);
    end;
  end;
end;

class function TRttiExplorer.GetClassAttribute<T>(AClass: TClass; ARecursive: Boolean): T;
var
  LAttr: TCustomAttribute;
  LTypeInfo: Pointer;
  LType: TRttiType;
  LClass: TClass;
begin
  LTypeInfo := TypeInfo(T);
  LClass := AClass;
  repeat
    LType := FRttiCache.GetType(LClass);
    for LAttr in LType.GetAttributes do
    begin
      if (LAttr.ClassInfo = LTypeInfo) then
      begin
        Exit(T(LAttr));
      end;
    end;

    if ARecursive then
      LClass := LClass.ClassParent
    else
      LClass := nil;
  until (LClass = nil);
  Result := nil;
end;

class function TRttiExplorer.GetClassFromClassInfo(AClassInfo: PTypeInfo): TClass;
var
  LType: TRttiType;
begin
  LType := FRttiCache.GetType(AClassInfo);
  Assert(LType.IsInstance);
  Result := LType.AsInstance.MetaclassType;
end;

class function TRttiExplorer.GetClassMembers<T>(AClass: TClass): IList<T>;
var
  LType: TRttiType;
  LField: TRttiField;
  LProp: TRttiProperty;
  LAttr: TCustomAttribute;
  LTypeInfo: Pointer;
begin
  Result := TCollections.CreateList<T>;
  LType := FRttiCache.GetType(AClass);
  LTypeInfo := TypeInfo(T);

  for LAttr in LType.GetAttributes do
  begin
    if LAttr is TORMAttribute then
    begin
      TORMAttribute(LAttr).MemberName := LType.Name;
      TORMAttribute(LAttr).EntityType := LType.Handle;
      TORMAttribute(LAttr).MemberKind := mkClass;
    end;
  end;

  for LField in LType.GetFields do
  begin
    for LAttr in LField.GetAttributes do
    begin
      if (LTypeInfo = LAttr.ClassInfo) or (InheritsFrom(LAttr.ClassType, LTypeInfo)) then
      begin
        TORMAttribute(LAttr).MemberKind := mkField;
        TORMAttribute(LAttr).MemberName := LField.Name;
        TORMAttribute(LAttr).EntityType := LType.Handle;
        TORMAttribute(LAttr).RttiMember := LField;
        Result.Add(T(LAttr));
      end;
    end;
  end;

  for LProp in LType.GetProperties do
  begin
    for LAttr in LProp.GetAttributes do
    begin
      if (LTypeInfo = LAttr.ClassInfo) or (InheritsFrom(LAttr.ClassType, LTypeInfo)) then
      begin
        TORMAttribute(LAttr).MemberKind := mkProperty;
        TORMAttribute(LAttr).MemberName := LProp.Name;
        TORMAttribute(LAttr).EntityType := LType.Handle;
        TORMAttribute(LAttr).RttiMember := LProp;
        Result.Add(T(LAttr));
      end;
    end;
  end;
end;

class function TRttiExplorer.GetColumnIsIdentity(AClass: TClass; AColumn: ColumnAttribute): Boolean;
begin
  Result := SameText(GetAutoGeneratedColumnMemberName(AClass), AColumn.MemberName);
end;

class function TRttiExplorer.GetColumns(AClass: TClass): IList<ColumnAttribute>;
begin
  Result := GetClassMembers<ColumnAttribute>(AClass);
end;

class procedure TRttiExplorer.GetDeclaredConstructors(AClass: TClass; AList: IList<TRttiMethod>);
var
  LType: TRttiType;
  LMethod: TRttiMethod;
begin
  LType := FRttiCache.GetType(AClass);
  for LMethod in LType.GetDeclaredMethods do
  begin
    if LMethod.IsConstructor then
    begin
      AList.Add(LMethod);
    end;
  end;
end;

class function TRttiExplorer.TryGetBasicMethod(const AMethodName: string; ATypeInfo: PTypeInfo;
  out AMethod: TRttiMethod): Boolean;
var
  LMethod, LResultMethod: TRttiMethod;
  iParCount, iCurrParCount, iCount: Integer;
  LType: TRttiType;
begin
  Result := False;
  LMethod := nil;
  iParCount := 0;
  iCurrParCount := 0;
  LType := FRttiCache.GetType(ATypeInfo);
  for LResultMethod in LType.GetMethods do
  begin
    if SameText(LResultMethod.Name, AMethodName) then
    begin
      Result := True;
      iCount := Length(LResultMethod.GetParameters);
      if (iCount < iParCount) or (iCount = 0) then
      begin
        AMethod := LResultMethod;
        Exit;
      end
      else
      begin
        if (iCount > iCurrParCount) then
        begin
          Inc(iParCount);
        end;

        iCurrParCount := iCount;
        LMethod := LResultMethod;
      end;
    end;
  end;
  AMethod := LMethod;
end;

class function TRttiExplorer.TryGetMethod(ATypeInfo: PTypeInfo; const AMethodName: string
  ; out AAddMethod: TRttiMethod; AParamCount: Integer): Boolean;
var
  LType: TRttiType;
  LMethod: TRttiMethod;
begin
  LType := FCtx.GetType(ATypeInfo);
  for LMethod in LType.GetMethods do
  begin
    if SameText(LMethod.Name, AMethodName) and (Length(LMethod.GetParameters) = AParamCount) then
    begin
      AAddMethod := LMethod;
      Exit(True);
    end;
  end;
  Result := False;
end;

class function TRttiExplorer.TryGetColumnAsForeignKey(AColumn: ColumnAttribute;
  out AForeignKeyCol: ForeignJoinColumnAttribute): Boolean;
var
  LNamedObject: TRttiNamedObject;
  LCustomAttribute: TCustomAttribute;
begin
  Result := False;
  LCustomAttribute := nil;

  LNamedObject := FRttiCache.GetNamedObject(AColumn.BaseEntityClass, AColumn.MemberName);
  if Assigned(LNamedObject) then
  begin
    LCustomAttribute := GetAttributeOfClass(LNamedObject, ForeignJoinColumnAttribute);
    Result := Assigned(LCustomAttribute);
  end;

  if Result then
    AForeignKeyCol := LCustomAttribute as ForeignJoinColumnAttribute;
end;

//class function TRttiExplorer.TryGetColumnByMemberName(AClass: TClass;
//  const AClassMemberName: string; out AColumn: ColumnAttribute): Boolean;
//begin
//  AColumn := TEntityCache.Get(AClass).ColumnByMemberName(AClassMemberName);
//  Result := Assigned(AColumn);
//end;

class function TRttiExplorer.TryGetPrimaryKeyValue(AColumns: IList<ColumnAttribute>;
  AResultset: IDBResultset; out AValue: TValue; out AColumn: ColumnAttribute): Boolean;
var
  LCol: ColumnAttribute;
  LVal: Variant;
begin
  for LCol in AColumns do
  begin
    if cpPrimaryKey in LCol.Properties then
    begin
      LVal := AResultset.GetFieldValue(LCol.ColumnName);
      AValue := TUtils.FromVariant(LVal);
      AColumn := LCol;
      Exit(True);
    end;
  end;
  Result := False;
end;

class function TRttiExplorer.GetEntities: IList<TClass>;
var
  LType: TRttiType;
  LClass: TClass;
  LEntity: EntityAttribute;
begin
  Result := TCollections.CreateList<TClass>;

  for LType in FCtx.GetTypes do
  begin
    if LType.IsInstance then
    begin
      LClass := LType.AsInstance.MetaclassType;
      LEntity := GetClassAttribute<EntityAttribute>(LClass);
      if Assigned(LEntity) then
      begin
        Result.Add(LClass);
      end;
    end;
  end;
end;

class function TRttiExplorer.GetEntityClass(classInfo: PTypeInfo): TClass;
var
  LRttiType: TRttiType;
begin
  LRttiType := GetEntityRttiType(classInfo);
  if not Assigned(LRttiType) then
    raise EORMUnsupportedType.CreateFmt('Unsupported type %s', [classInfo.Name]);

  Result := LRttiType.AsInstance.MetaclassType;
end;

class function TRttiExplorer.GetEntityRttiType(ATypeInfo: PTypeInfo): TRttiType;
var
  LRttiType: TRttiType;
  LCurrType: TRttiType;
  LEntityData: TEntityData;
begin
  LRttiType := FRttiCache.GetType(ATypeInfo);
  if LRttiType = nil then
    raise EORMUnsupportedType.CreateFmt('Cannot get type information from %s', [ATypeInfo.Name]);

  for LCurrType in LRttiType.GetGenericArguments do
  begin
    if LCurrType.IsInstance then
    begin
      if (TEntityCache.Get(LCurrType.AsInstance.MetaclassType) <> nil) then
        Exit(LCurrType);
    end;
  end;

  if not LRttiType.IsInstance then
    raise EORMUnsupportedType.CreateFmt('%s is not an instance type.', [ATypeInfo.Name]);

  LEntityData := TEntityCache.Get(LRttiType.AsInstance.MetaclassType);
  if not LEntityData.IsTableEntity then
    raise EORMUnsupportedType.CreateFmt('Type %s lacks [Table] attribute', [ATypeInfo.Name]);

  if not LEntityData.HasPrimaryKey then
    raise EORMUnsupportedType.CreateFmt('Type %s lacks primary key [Column]', [ATypeInfo.Name]);

  Result := LRttiType;
end;

class function TRttiExplorer.GetEntityRttiType<T>: TRttiType;
begin
  Result := GetEntityRttiType(TypeInfo(T));
end;

class function TRttiExplorer.GetForeignKeyColumn(AClass: TClass;
  const ABaseTablePrimaryKeyColumn: ColumnAttribute): ForeignJoinColumnAttribute;
var
  LForeignCol: ForeignJoinColumnAttribute;
begin
  for LForeignCol in TEntityCache.Get(AClass).ForeignColumns do
  begin
    if SameText(ABaseTablePrimaryKeyColumn.ColumnName, LForeignCol.ReferencedColumnName) then
    begin
      Exit(LForeignCol);
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetLastGenericArgumentType(ATypeInfo: PTypeInfo): TRttiType;
var
  LArgs: TArray<TRttiType>;
begin
  Result := FRttiCache.GetType(ATypeInfo);
  LArgs := Result.GetGenericArguments;
  if Length(LArgs) > 0 then
  begin
    Result := LArgs[High(LArgs)];
  end;
end;

class function TRttiExplorer.GetPrimaryKeyColumn(AClass: TClass): ColumnAttribute;
var
  LColumns: IList<ColumnAttribute>;
  LCol: ColumnAttribute;
begin
  LColumns := GetColumns(AClass);
  for LCol in LColumns do
  begin
    if (cpPrimaryKey in LCol.Properties) then
    begin
      Exit(LCol);
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetPrimaryKeyColumnMemberName(AClass: TClass): string;
var
  LCol: ColumnAttribute;
begin
  Result := '';

  LCol := GetPrimaryKeyColumn(AClass);
  if Assigned(LCol) then
  begin
    Result := LCol.MemberName;
  end;
end;

class function TRttiExplorer.GetPrimaryKeyColumnName(AClass: TClass): string;
var
  LCol: ColumnAttribute;
begin
  Result := '';

  LCol := GetPrimaryKeyColumn(AClass);
  if Assigned(LCol) then
  begin
    Result := LCol.ColumnName;
  end;
end;

class function TRttiExplorer.GetPrimaryKeyValue(AEntity: TObject): TValue;
begin
  Result := GetMemberValue(AEntity, TEntityCache.Get(AEntity.ClassType).PrimaryKeyColumn.MemberName);
end;

class function TRttiExplorer.GetQueryTextFromMethod(
  AMethod: TRttiMethod): string;
var
  LAttr: TCustomAttribute;
  LQueryAttribute: QueryAttribute;
begin
  Result := '';
  for LAttr in AMethod.GetAttributes do
  begin
    if LAttr is QueryAttribute then
    begin
      LQueryAttribute := QueryAttribute(LAttr);
      Result := LQueryAttribute.QueryText;
      Exit;
    end;
  end;
end;

class function TRttiExplorer.GetRawPointer(const AInstance: TValue): Pointer;
begin
  if AInstance.IsObject then
    Result := AInstance.AsObject
  else
    Result := AInstance.GetReferenceToRawData;
end;

class function TRttiExplorer.GetRelationsOf(AEntity: TObject): IList<TObject>;
var
  LType: TRttiType;
  LField: TRttiField;
  LProperty: TRttiProperty;
  LEntities: IList<TObject>;
begin
  Result := TCollections.CreateList<TObject>;
  //look for OneToMany or ManyToOne attributes
  LType := FRttiCache.GetType(AEntity.ClassType);
  for LField in LType.GetFields do
  begin
    if LField.HasCustomAttribute<ManyValuedAssociation> then
    begin
      LEntities := GetSubEntityFromMemberDeep(AEntity, LField);
      if LEntities.Any then
        Result.AddRange(LEntities);
    end;
  end;

  for LProperty in LType.GetProperties do
  begin
    if LProperty.HasCustomAttribute<ManyValuedAssociation> then
    begin
      LEntities := GetSubEntityFromMemberDeep(AEntity, LProperty);
      if LEntities.Any then
        Result.AddRange(LEntities);
    end;
  end;
end;

class function TRttiExplorer.GetRttiType(AEntity: TClass): TRttiType;
begin
  Result := TRttiContext.Create.GetType(AEntity);
end;

class function TRttiExplorer.GetMemberTypeInfo(AClass: TClass; const AMemberName: string): PTypeInfo;
var
  LNamedObj: TRttiNamedObject;
begin
  Result := nil;

  LNamedObj := FRttiCache.GetNamedObject(AClass, AMemberName);
  if Assigned(LNamedObj) then
  begin
    Result := LNamedObj.GetTypeInfo;
  end;
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMember: TRttiNamedObject): TValue;
begin
  if AMember is TRttiProperty then
    Result := TRttiProperty(AMember).GetValue(AEntity)
  else if AMember is TRttiField then
    Result := TRttiField(AMember).GetValue(AEntity)
  else
    Result := TValue.Empty;
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMemberName: string): TValue;
var
  LMember: TRttiNamedObject;
begin
  Result := GetMemberValue(AEntity, AMemberName, LMember);
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMembername: string;
  out ARttiMember: TRttiNamedObject): TValue;
begin
  ARttiMember := FRttiCache.GetNamedObject(AEntity.ClassType, AMembername);
  Result := GetMemberValue(AEntity, ARttiMember);
end;

class function TRttiExplorer.GetMemberValueDeep(const AInitialValue: TValue;
  ARttiType: TRttiType): TValue;
begin
  Result := AInitialValue;
  if TUtils.IsNullableType(Result.TypeInfo) then
  begin
    if not TUtils.TryGetNullableTypeValue(AInitialValue, Result) then
      Result := TValue.Empty;
  end
  else if TType.IsLazy(Result.TypeInfo) then
  begin
    if not TUtils.TryGetLazyTypeValue(AInitialValue, Result) then
      Result := TValue.Empty;
  end; 
end;

class function TRttiExplorer.GetMemberValueDeep(AEntity: TObject;
  const AMemberName: string): TValue;
var
  LMember: TRttiNamedObject;
begin
  Result := GetMemberValue(AEntity, AMemberName, LMember);

  if Result.IsEmpty then
    Exit;

  Result := GetMemberValueDeep(Result, LMember.GetType);
end;

class function TRttiExplorer.GetMethodSignature(AMethod: TRttiMethod): string;
begin
  Result := AMethod.ToString;
end;

class function TRttiExplorer.GetMethodWithLessParameters(AList: IList<TRttiMethod>): TRttiMethod;
var
  i, iParams, iParamsOld, ix: Integer;
begin
  Assert(AList.Any);
  ix := 0;
  iParamsOld := Length(AList[0].GetParameters);
  for i := 1 to AList.Count - 1 do
  begin
    iParams := Length(AList[i].GetParameters);
    if iParams < iParamsOld then
    begin
      iParamsOld := iParams;
      ix := i;
    end;
  end;

  Result := AList[ix];
end;

class function TRttiExplorer.GetNamedObject(AClass: TClass;
  const APropertyName: string): TRttiNamedObject;
var
  LType: TRttiType;
begin
  LType := FCtx.GetType(AClass);
  Result := LType.GetField(APropertyName);
  if not Assigned(Result) then
    Result := LType.GetProperty(APropertyName);
end;

class function TRttiExplorer.HasInstanceField(AClass: TClass): Boolean;
var
  LField: TRttiField;
  LProp: TRttiProperty;
begin
  //enumerate fields
  for LField in FCtx.GetType(AClass).GetFields do
  begin
    if (LField.FieldType.IsInstance) then
    begin
      Exit(True);
    end;
  end;

  for LProp in FCtx.GetType(AClass).GetProperties do
  begin
    if (LProp.PropertyType.IsInstance) then
    begin
      Exit(True);
    end;
  end;

  Result := False;
end;

class function TRttiExplorer.GetSequence(AClass: TClass): SequenceAttribute;
begin
  Result := GetClassAttribute<SequenceAttribute>(AClass, True);
end;

class function TRttiExplorer.GetSubEntityFromMemberDeep(AEntity: TObject; ARttiMember: TRttiNamedObject): IList<TObject>;
var
  LMemberValue: TValue;
  LDeepValue: TValue;
  LObjectList: IObjectList;
  LCurrent: TObject;
begin
  Result := TCollections.CreateList<TObject>;

  LMemberValue := GetMemberValue(AEntity, ARttiMember);
  if LMemberValue.IsEmpty then
    Exit;
    
  LDeepValue := GetMemberValueDeep(LMemberValue, ARttiMember.GetType);
  if LDeepValue.IsEmpty then
    Exit;
  
  if TUtils.IsEnumerable(LDeepValue, LObjectList) then
  begin
    for LCurrent in LObjectList do
    begin
      Result.Add(LCurrent);
    end;                       
    LDeepValue := TValue.Empty;
  end;

  if (LDeepValue.IsObject) and (LDeepValue.AsObject <> nil) then
    Result.Add(LDeepValue.AsObject);
end;

class function TRttiExplorer.GetTable(AClassInfo: PTypeInfo): TableAttribute;
var
  LClass: TClass;
begin
  LClass := GetClassFromClassInfo(AClassInfo);
  Result := GetTable(LClass);
end;

class function TRttiExplorer.GetTable(AClass: TClass): TableAttribute;
begin
  Result := GetClassAttribute<TableAttribute>(AClass, True);
end;

class function TRttiExplorer.GetUniqueConstraints(AClass: TClass): IList<UniqueConstraint>;
begin
  Result := GetClassMembers<UniqueConstraint>(AClass);
end;

class function TRttiExplorer.HasColumns(AClass: TClass): Boolean;
var
  LList: IList<ColumnAttribute>;
begin
  LList := GetColumns(AClass);
  Result := LList.Any;
end;

class function TRttiExplorer.HasSequence(AClass: TClass): Boolean;
begin
  Result := (GetSequence(AClass) <> System.Default(SequenceAttribute) );
end;

class function TRttiExplorer.InheritsFrom(AObjectInfo: TClass;
  AFromObjectInfo: PTypeInfo): Boolean;
var
  LClass: TClass;
begin
  if Assigned(AObjectInfo) then
  begin
    Result := AObjectInfo.ClassInfo = AFromObjectInfo;
  end
  else
  begin
    Exit(False);
  end;
  if not Result then
  begin
    LClass := AObjectInfo.ClassParent;
    if Assigned(LClass) then
      Result := InheritsFrom(LClass, AFromObjectInfo);
  end;
end;

//class function TRttiExplorer.IsValidEntity(AClass: TClass): Boolean;
//var
//  LEntityData: TEntityData;
//begin
//  LEntityData := TEntityCache.Get(AClass);
//
//  if not Assigned(LEntityData) then
//    Exit(False);
//
//  if not LEntityData.IsTableEntity then
//    Exit(False);
//
//  if not LEntityData.HasPrimaryKey then
//    Exit(False);
//
//  Result := True;
//end;

class procedure TRttiExplorer.SetMemberValue(AEntity: TObject; const AMemberColumn: ColumnAttribute;
  const AValue: TValue);
begin
  Assert(Assigned(AMemberColumn));
  SetMemberValue(AEntity, AMemberColumn.MemberName, AValue);
end;

class procedure TRttiExplorer.SetMemberValue(AEntity: TObject; const AMemberName: string; const AValue: TValue);
var
  LValue: TValue;
  LNamedObject: TRttiNamedObject;
begin
  LValue := TValue.Empty;

  LNamedObject := FRttiCache.GetNamedObject(AEntity.ClassType, AMemberName);
  if Assigned(LNamedObject) then
  begin
    if TUtils.TryConvert(AValue, LNamedObject, AEntity, LValue) then
    begin
      SetValue(AEntity, LNamedObject, LValue);
    end;
  end;
end;

class procedure TRttiExplorer.SetMemberValueSimple(AEntity: TObject; const AMemberName: string; const AValue: TValue);
var
  LNamedObject: TRttiNamedObject;
begin
  LNamedObject := FRttiCache.GetNamedObject(AEntity.ClassType, AMemberName);
  if Assigned(LNamedObject) then
  begin
    SetValue(AEntity, LNamedObject, AValue);
  end;
end;

class procedure TRttiExplorer.SetValue(AInstance: Pointer; ANamedObject: TRttiNamedObject; const AValue: TValue);

  procedure SetInternalValue;
  begin
    if ANamedObject.IsField then
      ANamedObject.AsField.SetValue(AInstance, AValue)
    else
      ANamedObject.AsProperty.SetValue(AInstance, AValue);
  end;

begin
  if ANamedObject is TRttiInstanceProperty then
  begin
    case AValue.Kind of
      tkInteger: SetOrdProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsInteger);
      tkFloat: SetFloatProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsExtended);
      tkString, tkLString: SetAnsiStrProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsType<AnsiString>);
      tkClass: SetObjectProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsObject) ;
      tkVariant: SetVariantProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsVariant);
      tkInterface: SetInterfaceProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsInterface);
      tkInt64: SetInt64Prop(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsInt64);
      tkDynArray: SetDynArrayProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.GetReferenceToRawData);
      tkUString, tkWString: SetStrProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsString)
    else
      SetInternalValue;
    end;
  end
  else
    SetInternalValue;
end;

{$ENDREGION}


{$REGION 'TRttiCache'}

constructor TRttiCache.Create;
begin
  inherited Create;
  FFields := TCollections.CreateDictionary<string,TRttiField>;
  FProperties := TCollections.CreateDictionary<string,TRttiProperty>;
  FTypes := TCollections.CreateDictionary<PTypeInfo,TRttiType>;
  FTypeFields := TCollections.CreateDictionary<PTypeInfo,IList<TRttiField>>;
end;

procedure TRttiCache.Clear;
begin
  FFields.Clear;
  FProperties.Clear;
  FTypes.Clear;
  FTypeFields.Clear;
end;

function TRttiCache.GetField(AClass: TClass; const AFieldName: string): TRttiField;
begin
  if not FFields.TryGetValue(GetKey(AClass, AFieldName), Result) then
    Result := nil;
end;

function TRttiCache.GetFieldsOfType(ATypeInfo: PTypeInfo): IList<TRttiField>;
begin
  if not FTypeFields.TryGetValue(ATypeInfo, Result) then
    Result := TCollections.CreateList<TRttiField>;
end;

function TRttiCache.GetKey(AClass: TClass; const AName: string): string;
begin
  Result := AClass.UnitName + '.' + AClass.ClassName + '$' + AName;
end;

function TRttiCache.GetNamedObject(AClass: TClass; const AMemberName: string): TRttiNamedObject;
begin
  Result := GetProperty(AClass, AMemberName);
  if Result <> nil then
    Exit;
  Result := GetField(AClass, AMemberName);
  if Result <> nil then
    Exit;
  Result := TRttiExplorer.GetNamedObject(AClass, AMemberName);
end;

function TRttiCache.GetProperty(AClass: TClass; const APropertyName: string): TRttiProperty;
begin
  if not FProperties.TryGetValue(GetKey(AClass, APropertyName), Result) then
    Result := nil;
end;

function TRttiCache.GetType(AClass: TClass): TRttiType;
begin
  Result := nil;
  if Assigned(AClass) then
  begin
    Result := GetType(AClass.ClassInfo);
    if Result = nil then
      Result := FCtx.GetType(AClass);
  end;
end;

function TRttiCache.GetType(ATypeInfo: PTypeInfo): TRttiType;
begin
  if not FTypes.TryGetValue(ATypeInfo, Result) then
    Result := FCtx.GetType(ATypeInfo);
end;

procedure TRttiCache.RebuildCache;
var
  LType: TRttiType;
  LClass: TClass;
  LProp: TRttiProperty;
  LField: TRttiField;
  LFields: IList<TRttiField>;
begin
  Clear;

  for LType in FCtx.GetTypes do
  begin
    FTypes.Add(LType.Handle, LType);

    if LType.IsInstance then
    begin
      LClass := LType.AsInstance.MetaclassType;

      if TRttiExplorer.HasColumns(LClass) then
      begin
        LFields := TCollections.CreateList<TRttiField>;
        for LField in LType.GetFields do
        begin
          FFields.Add(GetKey(LClass, LField.Name), LField);
          LFields.Add(LField);
        end;
        FTypeFields.Add(LType.Handle, LFields);

        for LProp in LType.GetProperties do
          FProperties.Add(GetKey(LClass, LProp.Name), LProp);
      end;
    end;
  end;
end;

{$ENDREGION}


end.
