{***************************************************************************}
{                                                                           }
{           Spring Framework for Delphi                                     }
{                                                                           }
{           Copyright (c) 2009-2014 Spring4D Team                           }
{                                                                           }
{           http://www.spring4d.org                                         }
{                                                                           }
{***************************************************************************}
{                                                                           }
{  Licensed under the Apache License, Version 2.0 (the "License");          }
{  you may not use this file except in compliance with the License.         }
{  You may obtain a copy of the License at                                  }
{                                                                           }
{      http://www.apache.org/licenses/LICENSE-2.0                           }
{                                                                           }
{  Unless required by applicable law or agreed to in writing, software      }
{  distributed under the License is distributed on an "AS IS" BASIS,        }
{  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. }
{  See the License for the specific language governing permissions and      }
{  limitations under the License.                                           }
{                                                                           }
{***************************************************************************}

{$I Spring.inc}

unit Spring.Persistence.Mapping.Attributes;

interface

uses
  Rtti,
  TypInfo;

type
  TFetchKind = (
    fkEager,
    fkLazy
  );

  TCascadeKind = (
    ckCascadeAll,
    ckCascadeMerge,
    ckCascadeRefresh,
    ckCascadeRemove
  );
  TCascadeKinds = set of TCascadeKind;

  TForeignStrategy = (
    fsOnDeleteSetNull,
    fsOnDeleteSetDefault,
    fsOnDeleteCascade,
    fsOnDeleteNoAction,
    fsOnUpdateSetNull,
    fsOnUpdateSetDefault,
    fsOnUpdateCascade,
    fsOnUpdateNoAction
  );
  TForeignStrategies = set of TForeignStrategy;

  TColumnProperty = (
    cpRequired,
    cpUnique,
    cpDontInsert,
    cpDontUpdate,
    cpPrimaryKey,
    cpNotNull,
    cpHidden
  );
  TColumnProperties = set of TColumnProperty;

  TDiscriminatorType = (
    dtString,
    dtInteger
  );

  TInheritenceStrategy = (
    isJoined,
    isSingleTable,
    isTablePerClass
  );

  TMemberKind = (
    mkField,
    mkProperty,
    mkClass
  );

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Represents query which should be used for given repository method.
  ///	</summary>
  {$ENDREGION}
  QueryAttribute = class(TCustomAttribute)
  private
    fQueryText: string;
  public
    constructor Create(const queryText: string);

    property QueryText: string read fQueryText;
  end;

  TORMAttribute = class(TCustomAttribute)
  private
    fMemberKind: TMemberKind;
    fMemberName: string;
    fEntityType: PTypeInfo;
    function GetBaseEntityClass: TClass;
    function GetMemberType: PTypeInfo;
  public
    property BaseEntityClass: TClass read GetBaseEntityClass;
    property EntityType: PTypeInfo read fEntityType write fEntityType;
    property MemberKind: TMemberKind read fMemberKind write fMemberKind;
    property MemberName: string read fMemberName write fMemberName;
    property MemberType: PTypeInfo read GetMemberType;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Specifies that the class is an entity.
  ///	</summary>
  {$ENDREGION}
  EntityAttribute = class(TORMAttribute);

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Specifies the primary key property or field of an entity.
  ///	</summary>
  {$ENDREGION}
  Id = class(TORMAttribute)end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  This annotation specifies the primary table for the annotated entity.
  ///	</summary>
  {$ENDREGION}
  TableAttribute = class(TORMAttribute)
  private
    fTableName: string;
    fSchema: string;
    function GetTableName: string;
    function GetNamespace: string;
  public
    constructor Create; overload;
    constructor Create(const tableName: string; const schema: string = ''); overload;

    property TableName: string read GetTableName;
    property Schema: string read fSchema;
    property Namespace: string read GetNamespace;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Specifies that field or property value should be autoincremented.
  ///	</summary>
  {$ENDREGION}
  AutoGenerated = class(TORMAttribute);

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  This annotation is used to specify that a unique constraint is to be
  ///	  included in the generated DDL for a primary or secondary table.
  ///	</summary>
  {$ENDREGION}
  UniqueConstraint = class(TORMAttribute);

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Specifies properties for databases which uses sequences instead of
  ///	  identities.
  ///	</summary>
  ///	<remarks>
  ///	  If ASeqSQL is defined then framework will execute this SQL statement
  ///	  when performing an insert. Returned value will be written into the 
  ///	  entity's primary key column.
  ///	</remarks>
  {$ENDREGION}
  SequenceAttribute = class(TORMAttribute)
  private
    fSequenceName: string;
    fInitialValue: NativeInt;
    fIncrement: Integer;
    fSequenceSQL: string;
  public
    constructor Create(const sequenceName: string; initialValue: NativeInt; increment: Integer);  overload;
    constructor Create(const sequenceSQL: string); overload;

    property SequenceName: string read fSequenceName;
    property InitialValue: NativeInt read fInitialValue;
    property Increment: Integer read fIncrement;
    property SequenceSQL: string read fSequenceSQL;
  end;

  Association = class(TORMAttribute)
  private
    fRequired: Boolean;
    fCascade: TCascadeKinds;
  public
    constructor Create(required: Boolean; cascade: TCascadeKinds);

    property Required: Boolean read fRequired;
    property Cascade: TCascadeKinds read fCascade;
  end;

  ManyValuedAssociation = class(Association)
  private
    fMappedBy: string;
  public
    constructor Create(required: Boolean; cascade: TCascadeKinds; const mappedBy: string); overload;

    property MappedBy: string read fMappedBy;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Defines a many-valued association with one-to-many multiplicity.
  ///	</summary>
  {$ENDREGION}
  OneToManyAttribute = class(ManyValuedAssociation);

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  This annotation defines a single-valued association to another entity
  ///	  class that has many-to-one multiplicity.
  ///	</summary>
  {$ENDREGION}
  ManyToOneAttribute = class(ManyValuedAssociation);

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Is used to specify a mapped column for joining an entity association.
  ///	</summary>
  {$ENDREGION}
  JoinColumn = class(TORMAttribute)
  private
    fName: string;
    fReferencedColumnName: string;
    fReferencedTableName: string;
  public
    constructor Create(const name, referencedTableName, referencedColumnName: string);

    property Name: string read fName;
    property ReferencedColumnName: string read fReferencedColumnName;
    property ReferencedTableName: string read fReferencedTableName;
  end;

  ForeignJoinColumnAttribute = class(JoinColumn)
  private
    fForeignStrategies: TForeignStrategies;
  public
    constructor Create(const name, referencedTableName, referencedColumnName: string;
      foreignStrategies: TForeignStrategies); overload;

    property ForeignStrategies: TForeignStrategies read fForeignStrategies write fForeignStrategies;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Is used to specify a mapped column for a persistent property or field.
  ///	</summary>
  {$ENDREGION}
  ColumnAttribute = class(TORMAttribute)
  private
    fColumnName: string;
    fProperties: TColumnProperties;
    fLength: Integer;
    fPrecision: Integer;
    fScale: Integer;
    fDescription: string;
    fIsIdentity: Boolean;
    function GetName: string;
  protected
    function GetIsDiscriminator: Boolean; virtual;
    function GetIsPrimaryKey: Boolean; virtual;
    function GetIsVersionColumn: Boolean; virtual;
  public
    constructor Create; overload;
    constructor Create(properties: TColumnProperties); overload;
    constructor Create(properties: TColumnProperties;
      length, precision, scale: Integer; const description: string = ''); overload;
    constructor Create(const columnName: string; properties: TColumnProperties = []); overload;
    constructor Create(const columnName: string; properties: TColumnProperties;
      length, precision, scale: Integer; const description: string = ''); overload;
    constructor Create(const columnName: string; properties: TColumnProperties;
      length: Integer; const description: string = ''); overload;
    constructor Create(const columnName: string; properties: TColumnProperties;
      precision, scale: Integer; const description: string = ''); overload;

    function CanInsert: Boolean; virtual;
    function CanUpdate: Boolean; virtual;

    property IsDiscriminator: Boolean read GetIsDiscriminator;
    property IsIdentity: Boolean read fIsIdentity write fIsIdentity;
    property IsPrimaryKey: Boolean read GetIsPrimaryKey;
    property IsVersionColumn: Boolean read GetIsVersionColumn;
    property ColumnName: string read GetName;
    property Properties: TColumnProperties read fProperties;
    property Length: Integer read fLength;
    property Precision: Integer read fPrecision;
    property Scale: Integer read fScale;
    property Description: string read fDescription;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Is used to implement optimistic locking
  ///	</summary>
  {$ENDREGION}
  VersionAttribute = class(ColumnAttribute)
  protected
    function GetIsVersionColumn: Boolean; override;
  public
    constructor Create;
  end;

  TColumnData = record
  public
    MemberName: string;
    TypeInfo: PTypeInfo;
    ColumnName: string;
    Properties: TColumnProperties;
    IsLazy: Boolean;
  public
    function IsPrimaryKey: Boolean;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Is used to specify the value of the discriminator column for entities
  ///	  of the given type.
  ///	</summary>
  {$ENDREGION}
  DiscriminatorValue = class(TORMAttribute)
  private
    fValue: TValue;
  public
    constructor Create(const value: TValue);

    property Value: TValue read fValue;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Is used to define the discriminator column for the SINGLE_TABLE and
  ///	  JOINED inheritance mapping strategies.
  ///	</summary>
  {$ENDREGION}
  DiscriminatorColumn = class(ColumnAttribute)
  private
    fName: string;
    fDiscriminatorType: TDiscriminatorType;
    fLength: Integer;
  protected
    function GetIsDiscriminator: Boolean; override;
  public
    constructor Create(const name: string; discriminatorType: TDiscriminatorType; length: Integer);

    property Name: string read fName;
    property DiscriminatorType: TDiscriminatorType read fDiscriminatorType;
    property Length: Integer read fLength;
  end;

  {$REGION 'Documentation'}
  ///	<summary>
  ///	  Defines the inheritance strategy to be used for an entity class
  ///	  hierarchy.
  ///	</summary>
  {$ENDREGION}
  Inheritence = class(TORMAttribute)
  private
    fStrategy: TInheritenceStrategy;
  public
    constructor Create(strategy: TInheritenceStrategy);

    property Strategy: TInheritenceStrategy read fStrategy;
  end;

  {TODO -oLinas -cGeneral : OrderBy attribute. see: http://docs.oracle.com/javaee/5/api/javax/persistence/OrderBy.html}
  {TODO -oLinas -cGeneral : ManyToMany attribute. see: http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToMany.html}

implementation

uses
  Spring.Helpers,
  Spring.Reflection;

{ TableAttribute }

constructor TableAttribute.Create;
begin
  inherited Create;
  fTableName := '';
  fSchema := '';
end;

constructor TableAttribute.Create(const tableName: string; const schema: string);
begin
  Create;
  fTableName := tableName;
  fSchema := schema;
end;

function TableAttribute.GetNamespace: string;
begin
  Result := '';
  if Schema <> '' then
    Result := Schema + '.';
  Result := Result + TableName;
end;

function TableAttribute.GetTableName: string;
begin
  Result := fTableName;
  if Result = '' then
  begin
    Result := MemberName;
    if (Result[1] = 'T') and (Length(Result) > 1) then
      Result := Copy(Result, 2, Length(Result));
  end;
end;

{ Sequence }

constructor SequenceAttribute.Create(const sequenceName: string; initialValue: NativeInt; increment: Integer);
begin
  inherited Create;
  fSequenceName := sequenceName;
  fInitialValue := initialValue;
  fIncrement := increment;
  fSequenceSQL := '';
end;

constructor SequenceAttribute.Create(const sequenceSQL: string);
begin
  inherited Create;
  fSequenceSQL := sequenceSQL;
end;

{ Association }

constructor Association.Create(required: Boolean; cascade: TCascadeKinds);
begin
  inherited Create;
  fRequired := required;
  fCascade := cascade;
end;

{ ManyValuedAssociation }

constructor ManyValuedAssociation.Create(required: Boolean; cascade: TCascadeKinds;
  const mappedBy: string);
begin
  Create(required, cascade);
  fMappedBy := mappedBy;
end;

{ JoinColumn }

constructor JoinColumn.Create(
  const name, referencedTableName, referencedColumnName: string);
begin
  inherited Create;
  fName := name;
  fReferencedColumnName := referencedColumnName;
  fReferencedTableName := referencedTableName;
end;

{ Column }

constructor ColumnAttribute.Create;
begin
  inherited Create;
  fLength := 50;
  fPrecision := 10;
  fScale := 2;
end;

constructor ColumnAttribute.Create(properties: TColumnProperties);
begin
  Create;
  fProperties := properties;
end;

constructor ColumnAttribute.Create(properties: TColumnProperties;
  length, precision, scale: Integer; const description: string);
begin
  Create(properties);
  fLength := length;
  fPrecision := precision;
  fScale := scale;
  fDescription := description;
end;

constructor ColumnAttribute.Create(const columnName: string;
  properties: TColumnProperties);
begin
  Create(properties);
  fColumnName := columnName;
end;

constructor ColumnAttribute.Create(const columnName: string;
  properties: TColumnProperties; length, precision, scale: Integer;
  const description: string);
begin
  Create(columnName, properties);
  fLength := length;
  fPrecision := precision;
  fScale := scale;
  fDescription := description;
end;

constructor ColumnAttribute.Create(const columnName: string;
  properties: TColumnProperties; length: Integer; const description: string);
begin
  Create(columnName, properties, length, 0, 0, description);
end;

constructor ColumnAttribute.Create(const columnName: string;
  properties: TColumnProperties; precision, scale: Integer;
  const description: string);
begin
  Create(columnName, properties, 0, precision, scale, description);
end;

function ColumnAttribute.CanInsert: Boolean;
begin
  Result := not (cpDontInsert in Properties) and not IsIdentity;
end;

function ColumnAttribute.CanUpdate: Boolean;
begin
  Result := not (cpDontUpdate in Properties) and not IsPrimaryKey;
end;

function ColumnAttribute.GetIsDiscriminator: Boolean;
begin
  Result := False;
end;

function ColumnAttribute.GetIsPrimaryKey: Boolean;
begin
  Result := cpPrimaryKey in Properties;
end;

function ColumnAttribute.GetIsVersionColumn: Boolean;
begin
  Result := False;
end;

function ColumnAttribute.GetName: string;
begin
  Result := fColumnName;
  if Result = '' then
    Result := MemberName;
end;

{ DiscriminatorValue }

constructor DiscriminatorValue.Create(const value: TValue);
begin
  inherited Create;
  fValue := value;
end;

{ DiscriminatorColumn }

constructor DiscriminatorColumn.Create(const name: string; discriminatorType: TDiscriminatorType; length: Integer);
begin
  inherited Create(name, [], length, 0, 0, '');
  fName := name;
  fDiscriminatorType := discriminatorType;
  fLength := length;
end;

function DiscriminatorColumn.GetIsDiscriminator: Boolean;
begin
  Result := True;
end;

{ Inheritence }

constructor Inheritence.Create(strategy: TInheritenceStrategy);
begin
  inherited Create;
  fStrategy := strategy;
end;

{ TORMAttribute }

function TORMAttribute.GetBaseEntityClass: TClass;
begin
  Result := TType.GetType(fEntityType).AsInstance.MetaclassType;
end;

function TORMAttribute.GetMemberType: PTypeInfo;
var
  rttiType: TRttiType;
  field: TRttiField;
  prop: TRttiProperty;
begin
  Result := nil;

  rttiType := TType.GetType(fEntityType);
  if rttiType.TryGetField(fMemberName, field) then
    Result := field.FieldType.Handle
  else if rttiType.TryGetProperty(fMemberName, prop) then
    Result := prop.PropertyType.Handle;
end;

{ ForeignJoinColumnAttribute }

constructor ForeignJoinColumnAttribute.Create(
  const name, referencedTableName, referencedColumnName: string;
  foreignStrategies: TForeignStrategies);
begin
  inherited Create(name, referencedTableName, referencedColumnName);
  fForeignStrategies := foreignStrategies;
end;

{ TColumnData }

function TColumnData.IsPrimaryKey: Boolean;
begin
  Result := cpPrimaryKey in Properties;
end;

{ VersionAttribute }

constructor VersionAttribute.Create;
begin
  inherited Create('_version');
end;

function VersionAttribute.GetIsVersionColumn: Boolean;
begin
  Result := True;
end;

{ QueryAttribute }

constructor QueryAttribute.Create(const queryText: string);
begin
  inherited Create;
  fQueryText := queryText;
end;

end.