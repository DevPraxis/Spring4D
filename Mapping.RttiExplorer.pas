(*
* Copyright (c) 2012, Linas Naginionis
* Contacts: lnaginionis@gmail.com or support@soundvibe.net
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the <organization> nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)
unit Mapping.RttiExplorer;

interface

uses
  Rtti, Generics.Collections, Mapping.Attributes, TypInfo;

type
  TRttiExplorer = class
  private
    class var FCtx: TRttiContext;
  public
    class function GetClassMembers<T: TORMAttribute>(AClass: TClass): TList<T>;
    class function GetClassAttribute<T: TORMAttribute>(AClass: TClass): T;
    class function GetTable(AClass: TClass): Table;
    class function GetUniqueConstraints(AClass: TClass): TList<UniqueConstraint>;
    class function GetAssociations(AClass: TClass): TList<Association>;
    class function GetColumns(AClass: TClass): TList<Column>;
    class function GetSequence(AClass: TClass): SequenceAttribute;
    class function HasSequence(AClass: TClass): Boolean;
    class function GetAutoGeneratedColumnMemberName(AClass: TClass): string;
    class function GetPrimaryKeyColumn(AClass: TClass): Column;
    class function GetPrimaryKeyColumnMemberName(AClass: TClass): string;
    class function GetPrimaryKeyColumnName(AClass: TClass): string;
    class function GetPrimaryKeyValue(AEntity: TObject): TValue;
    class function GetMemberValue(AEntity: TObject; const AMemberName: string): TValue; overload;
    class function GetMemberValue(AEntity: TObject; const AMember: TRttiMember): TValue; overload;
    class procedure SetMemberValue(AEntity: TObject; const AMemberName: string; const AValue: TValue); overload;
    class procedure SetMemberValue(AEntity: TObject; const AMemberColumn: Column; const AValue: TValue); overload;
    class function EntityChanged(AEntity1, AEntity2: TObject): Boolean;
    class function GetChangedMembers(AOriginalObj, ADirtyObj: TObject): TList<Column>; overload;
    class procedure GetChangedMembers(AOriginalObj, ADirtyObj: TObject; AList: TList<Column>); overload;
    class procedure CopyFieldValues(AEntityFrom, AEntityTo: TObject);
    class function Clone(AEntity: TObject): TObject;
    class function CreateType(AClass: TClass): TObject;
  end;

implementation

uses
  Core.Exceptions
  ,Core.Reflection
  ,Core.Utils
  ,Math
  ,Classes
  ;

(*
  Copyright (c) 2011, Stefan Glienke
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

  - Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
  - Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
  - Neither the name of this library nor the names of its contributors may be
    used to endorse or promote products derived from this software without
    specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
*)  

function ValueIsEqual(const Left, Right: TValue): Boolean;
begin  
  if Left.IsNumeric and Right.IsNumeric then
  begin
    if Left.IsOrdinal then
    begin
      if Right.IsOrdinal then
      begin
        Result := Left.AsOrdinal = Right.AsOrdinal;
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsOrdinal, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsOrdinal, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsOrdinal, Right.AsExtended);
      end;
    end else
    if Left.IsSingle then
    begin
      if Right.IsOrdinal then
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsOrdinal);
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsExtended);
      end;
    end else
    if Left.IsDouble then
    begin
      if Right.IsOrdinal then
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsOrdinal);
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsExtended);
      end;
    end
    else
    begin
      if Right.IsOrdinal then
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsOrdinal);
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsExtended);
      end;
    end;
  end else
  if Left.IsString and Right.IsString then
  begin
    Result := Left.AsString = Right.AsString;
  end else
  if Left.IsClass and Right.IsClass then
  begin
    Result := Left.AsClass = Right.AsClass;
  end else
  if Left.IsObject and Right.IsObject then
  begin
    Result := Left.AsObject = Right.AsObject;
  end else
  if Left.IsVariant and Right.IsVariant then
  begin
    Result := Left.AsVariant = Right.AsVariant;
  end else
  if Left.IsPointer and Right.IsPointer then
  begin
    Result := Left.AsPointer = Right.AsPointer;
  end else
  if Left.TypeInfo = Right.TypeInfo then
  begin
    Result := Left.AsPointer = Right.AsPointer;
  end else
  begin
    Result := False;
  end;
end;


{ TRttiExplorer }

class function TRttiExplorer.Clone(AEntity: TObject): TObject;
begin
  Assert(Assigned(AEntity));

  Result := AEntity.ClassType.Create;
  CopyFieldValues(AEntity, Result);
end;

class procedure TRttiExplorer.CopyFieldValues(AEntityFrom, AEntityTo: TObject);
var
  LField: TRttiField;
  LType: TRttiType;
  LValue, LValueInstance: TValue;
  LObj: TObject;
begin
  Assert(AEntityFrom.ClassType = AEntityTo.ClassType);
  Assert(Assigned(AEntityFrom) and Assigned(AEntityTo));

  LType := FCtx.GetType(AEntityFrom.ClassInfo);
  for LField in LType.GetFields do
  begin
    if LField.FieldType.IsInstance then
    begin
      LValue := TRttiExplorer.CreateType(LField.FieldType.AsInstance.MetaclassType);
      LObj := LValue.AsObject;
      LValueInstance := LField.GetValue(AEntityFrom);
      if LObj is TPersistent then
      begin
        TPersistent(LObj).Assign(LValueInstance.AsObject as TPersistent);
      end;
    end
    else
      LValue := LField.GetValue(AEntityFrom);

    LField.SetValue(AEntityTo, LValue);
  end;
  {TODO -oLinas -cGeneral : what to do with properties? Should we need to write them too?}
end;

class function TRttiExplorer.CreateType(AClass: TClass): TObject;
begin
  Result := AClass.Create;
end;

class function TRttiExplorer.EntityChanged(AEntity1, AEntity2: TObject): Boolean;
var
  LChangedMembers: TList<Column>;
begin
  LChangedMembers := GetChangedMembers(AEntity1, AEntity2);
  try
    Result := (LChangedMembers.Count > 0);
  finally
    LChangedMembers.Free;
  end;
end;

class function TRttiExplorer.GetAssociations(AClass: TClass): TList<Association>;
begin
  Result := GetClassMembers<Association>(AClass);
end;

class function TRttiExplorer.GetAutoGeneratedColumnMemberName(AClass: TClass): string;
var
  LIds: TList<AutoGenerated>;
begin
  Result := '';

  LIds := GetClassMembers<AutoGenerated>(AClass);
  try
    if LIds.Count > 0 then
    begin
      Result := LIds.First.ClassMemberName;
    end;
  finally
    LIds.Free;
  end;
end;

class function TRttiExplorer.GetChangedMembers(AOriginalObj, ADirtyObj: TObject): TList<Column>;
begin
  Result := TList<Column>.Create;
  GetChangedMembers(AOriginalObj, ADirtyObj, Result);
end;

class procedure TRttiExplorer.GetChangedMembers(AOriginalObj, ADirtyObj: TObject; AList: TList<Column>);
var
  LRttiType: TRttiType;
  LMember: TRttiMember;
  LOriginalValue, LDirtyValue: TValue;
  LCol: Column;
  LColumns: TList<Column>;
begin
  Assert(AOriginalObj.ClassType = ADirtyObj.ClassType);
  LRttiType := FCtx.GetType(AOriginalObj.ClassType);
  AList.Clear;

  LColumns := GetColumns(AOriginalObj.ClassType);
  try
    for LCol in LColumns do
    begin
      if not LCol.IsDiscriminator then
      begin

        case LCol.MemberType of
          mtField:    LMember := LRttiType.GetField(LCol.ClassMemberName);
          mtProperty: LMember := LRttiType.GetProperty(LCol.ClassMemberName);
        else
          LMember := nil;
        end;

        if not Assigned(LMember) then
          raise EUnknownMember.Create('Unknown column member: ' + LCol.ClassMemberName);

        LOriginalValue := GetMemberValue(AOriginalObj, LMember);
        LDirtyValue := GetMemberValue(ADirtyObj, LMember);

        if not Core.Reflection.SameValue(LOriginalValue, LDirtyValue) then
          AList.Add(LCol);
      end;
    end;
  finally
    LColumns.Free;
  end;
end;

class function TRttiExplorer.GetClassAttribute<T>(AClass: TClass): T;
var
  LAttr: TCustomAttribute;
  LTypeInfo: Pointer;
  LType: TRttiType;
begin
  LTypeInfo := TypeInfo(T);
  LType := FCtx.GetType(AClass);
  for LAttr in LType.GetAttributes do
  begin
    if (LAttr.ClassInfo = LTypeInfo) then
    begin
      Exit(T(LAttr));
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetClassMembers<T>(AClass: TClass): TList<T>;
var
  LType: TRttiType;
  LField: TRttiField;
  LProp: TRttiProperty;
  LAttr: TCustomAttribute;
  LTypeInfo: Pointer;
begin
  Result := TList<T>.Create;
  LType := FCtx.GetType(AClass);
  LTypeInfo := TypeInfo(T);
  for LField in LType.GetFields do
  begin
    for LAttr in LField.GetAttributes do
    begin
      if (LTypeInfo = LAttr.ClassInfo) then
      begin
        TORMAttribute(LAttr).MemberType := mtField;
        TORMAttribute(LAttr).ClassMemberName := LField.Name;
        Result.Add(T(LAttr));
      end;
    end;
  end;

  for LProp in LType.GetProperties do
  begin
    for LAttr in LProp.GetAttributes do
    begin
      if (LTypeInfo = LAttr.ClassInfo) then
      begin
        TORMAttribute(LAttr).MemberType := mtProperty;
        TORMAttribute(LAttr).ClassMemberName := LProp.Name;
        Result.Add(T(LAttr));
      end;
    end;
  end;
end;

class function TRttiExplorer.GetColumns(AClass: TClass): TList<Column>;
begin
  Result := GetClassMembers<Column>(AClass);
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMember: TRttiMember): TValue;
begin
  if AMember is TRttiField then
  begin
    Result := TRttiField(AMember).GetValue(AEntity);
  end
  else if AMember is TRttiProperty then
  begin
    Result := TRttiProperty(AMember).GetValue(AEntity); 
  end
  else
  begin
    Result := TValue.Empty;
  end;
end;

class function TRttiExplorer.GetPrimaryKeyColumn(AClass: TClass): Column;
var
  LColumns: TList<Column>;
  LCol: Column;
begin
  LColumns := GetColumns(AClass);
  try
    for LCol in LColumns do
    begin
      if (cpPrimaryKey in LCol.Properties) then
      begin
        Exit(LCol);
      end;
    end;
  finally
    LColumns.Free;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetPrimaryKeyColumnMemberName(AClass: TClass): string;
var
  LCol: Column;
begin
  Result := '';

  LCol := GetPrimaryKeyColumn(AClass);
  if Assigned(LCol) then
  begin
    Result := LCol.ClassMemberName;
  end;
end;

class function TRttiExplorer.GetPrimaryKeyColumnName(AClass: TClass): string;
var
  LCol: Column;
begin
  Result := '';

  LCol := GetPrimaryKeyColumn(AClass);
  if Assigned(LCol) then
  begin
    Result := LCol.Name;
  end;
end;

class function TRttiExplorer.GetPrimaryKeyValue(AEntity: TObject): TValue;
begin
  Result := GetMemberValue(AEntity, GetPrimaryKeyColumnMemberName(AEntity.ClassType));
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMemberName: string): TValue;
var
  LField: TRttiField;
  LProp: TRttiProperty;
begin
  LField := FCtx.GetType(AEntity.ClassInfo).GetField(AMemberName);
  if Assigned(LField) then
  begin
    Result := LField.GetValue(AEntity);
    Exit;
  end;

  LProp := FCtx.GetType(AEntity.ClassInfo).GetProperty(AMemberName);
  if Assigned(LProp) then
  begin
    Result := LProp.GetValue(AEntity);
    Exit;
  end;

  Result := TValue.Empty;
end;

class function TRttiExplorer.GetSequence(AClass: TClass): SequenceAttribute;
begin
  Result := GetClassAttribute<SequenceAttribute>(AClass);
end;

class function TRttiExplorer.GetTable(AClass: TClass): Table;
begin
  Result := GetClassAttribute<Table>(AClass);
end;

class function TRttiExplorer.GetUniqueConstraints(AClass: TClass): TList<UniqueConstraint>;
begin
  Result := GetClassMembers<UniqueConstraint>(AClass);
end;

class function TRttiExplorer.HasSequence(AClass: TClass): Boolean;
begin
  Result := (GetSequence(AClass) <> System.Default(SequenceAttribute) );
end;

class procedure TRttiExplorer.SetMemberValue(AEntity: TObject; const AMemberColumn: Column;
  const AValue: TValue);
begin
  Assert(Assigned(AMemberColumn));
  SetMemberValue(AEntity, AMemberColumn.ClassMemberName, AValue);
end;

class procedure TRttiExplorer.SetMemberValue(AEntity: TObject; const AMemberName: string; const AValue: TValue);
var
  LField: TRttiField;
  LProp: TRttiProperty;
  LValue: TValue;
  LObject: TObject;
begin
  LValue := TValue.Empty;
  LField := FCtx.GetType(AEntity.ClassInfo).GetField(AMemberName);
  if Assigned(LField) then
  begin
    if TUtils.TryConvert(AValue, LField.RttiType.Handle, LValue) then
    begin
      LField.SetValue(AEntity, LValue);
    end;
  end
  else
  begin
    LProp := FCtx.GetType(AEntity.ClassInfo).GetProperty(AMemberName);
    if Assigned(LProp) then
    begin
      if TUtils.TryConvert(AValue, LProp.RttiType.Handle, LValue) then
      begin
        LProp.SetValue(AEntity, LValue);
      end;
    end;
  end;

  if LValue.IsObject then
  begin
    LObject := LValue.AsObject;
    if Assigned(LObject) then
      LObject.Free;
  end;

  if AValue.IsObject then
  begin
    LObject := AValue.AsObject;
    if Assigned(LObject) then
      LObject.Free;
  end;
end;



end.
