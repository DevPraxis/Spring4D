(*
* Copyright (c) 2012, Linas Naginionis
* Contacts: lnaginionis@gmail.com or support@soundvibe.net
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the <organization> nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)
unit Spring.Persistence.Mapping.RttiExplorer;

interface

uses
  Rtti, Spring.Persistence.Mapping.Attributes, TypInfo, Spring.Persistence.Core.Interfaces
  , Spring.Collections;

type
  TRttiCache = class
  private
    FFields: IDictionary<string, TRttiField>;
    FProperties: IDictionary<string,TRttiProperty>;
    FTypes: IDictionary<PTypeInfo, TRttiType>;
    FTypeFields: IDictionary<PTypeInfo,IList<TRttiField>>;
    FCtx: TRttiContext;
  protected
    function GetKey(AClass: TClass; const AName: string): string;
  public
    constructor Create(); virtual;
    destructor Destroy; override;

    procedure Clear;
    procedure RebuildCache(); virtual;

    function GetField(AClass: TClass; const AFieldName: string): TRttiField;
    function GetProperty(AClass: TClass; const APropertyName: string): TRttiProperty;
    function GetNamedObject(AClass: TClass; const APropertyName: string): TRttiNamedObject;
    function GetType(ATypeInfo: PTypeInfo): TRttiType; overload;
    function GetType(AClass: TClass): TRttiType; overload;
    function GetFieldsOfType(ATypeInfo: PTypeInfo): IList<TRttiField>;
  end;

  TRttiExplorer = class
  private
    class var FCtx: TRttiContext;
    class var FRttiCache: TRttiCache;
  protected
    class constructor Create;
    class destructor Destroy;
  public
    class function Clone(AEntity: TObject): TObject;
    class function CreateNewClass<T>: T;
    class function CreateNewInterface(AInterfaceTypeInfo: PTypeInfo; AClassTypeInfo: PTypeInfo): IInvokable; overload;
    class function CreateNewInterface<TInterfaceType, TClassType>: TInterfaceType; overload;
    class function CreateType(AClass: TClass): TObject; overload;
    class function CreateType(ATypeInfo: PTypeInfo): TObject; overload;
    class function CreateExternalType(AClass: TClass; const Args: array of TValue): TObject;
    class function EntityChanged(AEntity1, AEntity2: TObject): Boolean;
    class function GetAttributeOfClass(ARttiObject: TRttiObject; AClass: TClass): TCustomAttribute;
    class function GetAsRecord(ARttiObject: TRttiNamedObject): TRttiRecordType;
    class function GetAssociations(AClass: TClass): IList<Association>;
    class function GetAutoGeneratedColumnMemberName(AClass: TClass): string;
    class function GetChangedMembers(AOriginalObj, ADirtyObj: TObject): IList<ColumnAttribute>; overload;
    class function GetClassAttribute<T: TORMAttribute>(AClass: TClass; ARecursive: Boolean = False): T;
    class function GetClassMembers<T: TORMAttribute>(AClass: TClass): IList<T>; overload;
    class function GetColumns(AClass: TClass): IList<ColumnAttribute>; overload;
    class function GetColumnIsIdentity(AClass: TClass; AColumn: ColumnAttribute): Boolean;
    class procedure GetDeclaredConstructors(AClass: TClass; AList: IList<TRttiMethod>);
    class function GetMethodWithLessParameters(AList: IList<TRttiMethod>): TRttiMethod;
    class function GetEntities(): IList<TClass>;
    class function GetEntityRttiType(ATypeInfo: PTypeInfo): TRttiType; overload;
    class function GetEntityRttiType<T>(): TRttiType; overload;
    class function HasInstanceField(AClass: TClass): Boolean;
    class function GetSubEntityFromMemberDeep(AEntity: TObject; ARttiMember: TRttiNamedObject): IList<TObject>;
    class function GetRelationsOf(AEntity: TObject): IList<TObject>;
    class function GetLastGenericArgumentType(ATypeInfo: PTypeInfo): TRttiType;
    class function GetForeignKeyColumn(AClass: TClass; const ABaseTablePrimaryKeyColumn: ColumnAttribute): ForeignJoinColumnAttribute;
    class function GetMemberValue(AEntity: TObject; const AMember: TRttiNamedObject): TValue; overload;
    class function GetMemberValue(AEntity: TObject; const AMemberName: string): TValue; overload;
    class function GetMemberValue(AEntity: TObject; const AMembername: string; out ARttiMember: TRttiNamedObject): TValue; overload;
    class function GetMemberValueDeep(AEntity: TObject; const AMemberName: string): TValue; overload;
    class function GetMemberValueDeep(const AInitialValue: TValue; ARttiType: TRttiType): TValue; overload;
    class function GetPrimaryKeyColumn(AClass: TClass): ColumnAttribute;
    class function GetPrimaryKeyColumnMemberName(AClass: TClass): string;
    class function GetPrimaryKeyColumnName(AClass: TClass): string;
    class function GetPrimaryKeyValue(AEntity: TObject): TValue;
    class function GetRawPointer(const AInstance: TValue): Pointer;
    class function GetRttiType(AEntity: TClass): TRttiType;
    class function GetSequence(AClass: TClass): SequenceAttribute;
    class function GetTable(AClass: TClass): TableAttribute; overload;
    class function GetTable(AClassInfo: PTypeInfo): TableAttribute; overload;
    class function GetClassFromClassInfo(AClassInfo: PTypeInfo): TClass;
    class function GetMemberTypeInfo(AClass: TClass; const AMemberName: string): PTypeInfo;
    class function GetUniqueConstraints(AClass: TClass): IList<UniqueConstraint>;
    class function HasSequence(AClass: TClass): Boolean;
    class function HasColumns(AClass: TClass): Boolean;
    class function TryGetColumnAsForeignKey(AColumn: ColumnAttribute; out AForeignKeyCol: ForeignJoinColumnAttribute): Boolean;
    class function TryGetBasicMethod(const AMethodName: string; ATypeInfo: PTypeInfo; out AMethod: TRttiMethod): Boolean;
    class function TryGetColumnByMemberName(AClass: TClass; const AClassMemberName: string; out AColumn: ColumnAttribute): Boolean;
    class function TryGetEntityClass(ATypeInfo: PTypeInfo; out AClass: TClass): Boolean; overload;
    class function TryGetEntityClass<T>(out AClass: TClass): Boolean; overload;
    class function TryGetPrimaryKeyValue(AColumns: IList<ColumnAttribute>; AResultset: IDBResultset; out AValue: TValue; out AColumn: ColumnAttribute): Boolean;
    class function TryGetMethod(ATypeInfo: PTypeInfo; const AMethodName: string; out AAddMethod: TRttiMethod; AParamCount: Integer = 1): Boolean;
    class procedure CopyFieldValues(AEntityFrom, AEntityTo: TObject);
    class procedure DestroyClass<T>(var AObject: T);
    class procedure GetChangedMembers(AOriginalObj, ADirtyObj: TObject; AList: IList<ColumnAttribute>); overload;
    class procedure GetClassMembers<T: TORMAttribute>(AClass: TClass; AList: IList<T>); overload;
    class procedure GetColumns(AClass: TClass; AColumns: IList<ColumnAttribute>); overload;
    class procedure SetMemberValue(AManager: TObject; AEntity: TObject; const AMemberColumn: ColumnAttribute; const AValue: TValue); overload;
    class procedure SetMemberValue(AManager: TObject; AEntity: TObject; const AMemberName: string; const AValue: TValue); overload;
    class procedure SetMemberValueSimple(AEntity: TObject; const AMemberName: string; const AValue: TValue);
    class procedure SetValue(AInstance: Pointer; ANamedObject: TRttiNamedObject; const AValue: TValue);

    class function InheritsFrom(AObjectInfo: TClass; AFromObjectInfo: PTypeInfo): Boolean;
    class function GetNamedObject(AClass: TClass; const APropertyName: string): TRttiNamedObject;

    class function GetQueryTextFromMethod(AMethod: TRttiMethod): string;
    class function GetMethodSignature(AMethod: TRttiMethod): string;

    class property RttiCache: TRttiCache read FRttiCache;
  end;

implementation

uses
  Spring.Persistence.Core.Exceptions
  ,Spring.Persistence.Core.Reflection
  ,Spring.Persistence.Core.EntityCache
  ,Spring.Persistence.Core.Utils
  ,Spring.Persistence.Core.CollectionAdapterResolver
  ,SysUtils
  ,Math
  ,Classes
  ,StrUtils
  ;


(*
  Copyright (c) 2011, Stefan Glienke
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

  - Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
  - Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
  - Neither the name of this library nor the names of its contributors may be
    used to endorse or promote products derived from this software without
    specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
*)  

function ValueIsEqual(const Left, Right: TValue): Boolean;
begin  
  if Left.IsNumeric and Right.IsNumeric then
  begin
    if Left.IsOrdinal then
    begin
      if Right.IsOrdinal then
      begin
        Result := Left.AsOrdinal = Right.AsOrdinal;
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsOrdinal, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsOrdinal, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsOrdinal, Right.AsExtended);
      end;
    end else
    if Left.IsSingle then
    begin
      if Right.IsOrdinal then
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsOrdinal);
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsSingle, Right.AsExtended);
      end;
    end else
    if Left.IsDouble then
    begin
      if Right.IsOrdinal then
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsOrdinal);
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsDouble, Right.AsExtended);
      end;
    end
    else
    begin
      if Right.IsOrdinal then
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsOrdinal);
      end else
      if Right.IsSingle then
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsSingle);
      end else
      if Right.IsDouble then
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsDouble);
      end
      else
      begin
        Result := Math.SameValue(Left.AsExtended, Right.AsExtended);
      end;
    end;
  end else
  if Left.IsString and Right.IsString then
  begin
    Result := Left.AsString = Right.AsString;
  end else
  if Left.IsClass and Right.IsClass then
  begin
    Result := Left.AsClass = Right.AsClass;
  end else
  if Left.IsObject and Right.IsObject then
  begin
    Result := Left.AsObject = Right.AsObject;
  end else
  if Left.IsVariant and Right.IsVariant then
  begin
    Result := Left.AsVariant = Right.AsVariant;
  end else
  if Left.IsPointer and Right.IsPointer then
  begin
    Result := Left.AsPointer = Right.AsPointer;
  end else
  if Left.TypeInfo = Right.TypeInfo then
  begin
    Result := Left.AsPointer = Right.AsPointer;
  end else
  begin
    Result := False;
  end;
end;

procedure CopyRecord(Dest, Source, TypeInfo: Pointer);
asm
  jmp System.@CopyRecord
end;

function GetInlineSize(TypeInfo: PTypeInfo): Integer;
begin
  if TypeInfo = nil then
    Exit(0);

  case TypeInfo^.Kind of
    tkInteger, tkEnumeration, tkChar, tkWChar, tkSet:
      case GetTypeData(TypeInfo)^.OrdType of
        otSByte, otUByte: Exit(1);
        otSWord, otUWord: Exit(2);
        otSLong, otULong: Exit(4);
      else
        Exit(0);
      end;
    tkFloat:
      case GetTypeData(TypeInfo)^.FloatType of
        ftSingle: Exit(4);
        ftDouble: Exit(8);
        ftExtended: Exit(SizeOf(Extended));
        ftComp: Exit(8);
        ftCurr: Exit(8);
      else
        Exit(0);
      end;
    tkClass, tkClassRef: Exit(SizeOf(Pointer));
    tkMethod: Exit(SizeOf(TMethod));
    tkInt64: Exit(8);
    tkDynArray, tkUString, tkLString, tkWString, tkInterface: Exit(-SizeOf(Pointer));
    tkString: Exit(-GetTypeData(TypeInfo)^.MaxLength + 1);
    tkPointer: Exit(SizeOf(Pointer));
    tkRecord: Exit(-GetTypeData(TypeInfo)^.RecSize);
    tkArray: Exit(-GetTypeData(TypeInfo)^.ArrayData.Size);
    tkVariant: Exit(-SizeOf(Variant));
  else
    Exit(0);
  end;
end;

procedure CopyObject(Source: TObject; var Dest: TObject);
var
  ClassPtr: TClass;
  InitTable: PTypeInfo;
  TypeData: PTypeData;
  SourcePtr, DestPtr: Pointer;
  Size: Integer;
  ManagedField: PManagedField;
begin
  ClassPtr := Source.ClassType;
  if TEntityCache.Get(ClassPtr).HasInstanceField then
    TRttiExplorer.CopyFieldValues(Source, Dest)
  else
  begin
    SourcePtr := Source;
    DestPtr := TObject(Dest);
    Size := 0;
    InitTable := PPointer(PByte(ClassPtr) + vmtInitTable)^;
    if InitTable <> nil then
    begin
      // Copy ref-counted values
      CopyArray(DestPtr, SourcePtr, ClassPtr, 1);
      // Determine remaining memory size to be copied
      TypeData := GetTypeData(InitTable);
      ManagedField := Pointer(PByte(TypeData) + SizeOf(Integer) * 2);
      Inc(ManagedField, TypeData.ManagedFldCount - 1);
      Size := ManagedField.FldOffset + Abs(GetInlineSize(ManagedField.TypeRef^));

      if Size < Source.InstanceSize then
      begin
        SourcePtr := PByte(SourcePtr) + Size;
        DestPtr := PByte(DestPtr) + Size;
      end;
    end;
    Move(SourcePtr^, DestPtr^, Source.InstanceSize - Size - hfFieldSize); // do not copy the hidden MonitorField
  end;
end;


{ TRttiExplorer }

class function TRttiExplorer.Clone(AEntity: TObject): TObject;
begin
  Assert(Assigned(AEntity));
  Result := AEntity.ClassType.Create;
 // {$IF not defined(CPU386)}
  CopyFieldValues(AEntity, Result);
 // {$ELSE}
 // CopyObject(AEntity, Result);
 // {$IFEND}
end;

class procedure TRttiExplorer.CopyFieldValues(AEntityFrom, AEntityTo: TObject);
var
  i: Integer;
  LField: TRttiField;
  LFields: IList<TRttiField>;
 // LType: TRttiType;
  LValueTo: TValue;
  LValueFrom: TObject;
begin
  if (AEntityFrom = nil) then
    Exit;
  Assert(AEntityFrom.ClassType = AEntityTo.ClassType);
  Assert(Assigned(AEntityFrom) and Assigned(AEntityTo));
  
 // LType := FRttiCache.GetType(AEntityFrom.ClassInfo);
  LFields := FRttiCache.GetFieldsOfType(AEntityFrom.ClassInfo);
  for i := 0 to LFields.Count - 1 do
  begin
    LField := LFields[i];
    if LField.FieldType.IsInstance then
    begin
      LValueTo := TRttiExplorer.CreateType(LField.FieldType.AsInstance.MetaclassType);
      //LValueTo := LField.FieldType.AsInstance.MetaclassType.Create;
      LValueFrom := LField.GetValue(AEntityFrom).AsObject;
      if LValueTo.AsObject is TPersistent then
      begin
        TPersistent(LValueTo.AsObject).Assign(LValueFrom as TPersistent);
      end
      else
        CopyFieldValues(LValueFrom, LValueTo.AsObject);
    end
    else
      LValueTo := LField.GetValue(AEntityFrom);
  
    LField.SetValue(AEntityTo, LValueTo);
  end;
end;

class constructor TRttiExplorer.Create;
begin
  FRttiCache := TRttiCache.Create;
  FRttiCache.RebuildCache;
end;

class function TRttiExplorer.CreateExternalType(AClass: TClass;
  const Args: array of TValue): TObject;
var
  LMethod: TRttiMethod;
  LType: TRttiType;
begin
  Result := nil;
  LType := TRttiContext.Create.GetType(AClass);
  for LMethod in LType.GetMethods do
  begin
    if (LMethod.IsConstructor) and (Length(LMethod.GetParameters) = Length(Args)) then
    begin
      Result := LMethod.Invoke(LType.AsInstance.MetaclassType, Args).AsObject;
      Break;
    end;
  end;
end;

class function TRttiExplorer.CreateNewClass<T>: T;
var
  rType: TRttiType;
  AMethCreate: TRttiMethod;
  instanceType: TRttiInstanceType;
begin
  rType := FRttiCache.GetType(TypeInfo(T));// TRttiContext.Create.GetType(TypeInfo(T));
  if rType.IsInstance then
  begin
    for AMethCreate in rType.GetMethods do
    begin
      if (AMethCreate.IsConstructor) and (Length(AMethCreate.GetParameters) = 0) then
      begin
        instanceType := rType.AsInstance;
        Result := AMethCreate.Invoke(instanceType.MetaclassType, []).AsType<T>;
        Break;
      end;
    end;
  end;
end;

class function TRttiExplorer.CreateNewInterface(AInterfaceTypeInfo, AClassTypeInfo: PTypeInfo): IInvokable;
var
  rType: TRttiType;
begin
  rType := FRttiCache.GetType(AInterfaceTypeInfo);
  if rType.IsInterface then
  begin
    Supports(CreateType(AClassTypeInfo), rType.AsInterface.GUID, Result);
  end;
end;

class function TRttiExplorer.CreateNewInterface<TInterfaceType, TClassType>: TInterfaceType;
var
  rType: TRttiType;
begin
  rType := FRttiCache.GetType(TypeInfo(TInterfaceType));
  if rType.IsInterface then
  begin
    Supports(CreateType(TypeInfo(TClassType)), rType.AsInterface.GUID, Result);
  end;
end;

class function TRttiExplorer.CreateType(ATypeInfo: PTypeInfo): TObject;
var
  rType: TRttiType;
  AMethCreate: TRttiMethod;
  instanceType: TRttiInstanceType;
begin
  rType := FRttiCache.GetType(ATypeInfo);
  if rType.IsInstance then
  begin
    for AMethCreate in rType.GetMethods do
    begin
      if (AMethCreate.IsConstructor) and (Length(AMethCreate.GetParameters) = 0) then
      begin
        instanceType := rType.AsInstance;
        Result := AMethCreate.Invoke(instanceType.MetaclassType, []).AsObject;
        Exit;
      end;
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.CreateType(AClass: TClass): TObject;
begin
  Result := CreateType(AClass.ClassInfo);
end;

class destructor TRttiExplorer.Destroy;
begin
  FRttiCache.Free;
end;

class procedure TRttiExplorer.DestroyClass<T>(var AObject: T);
begin
  if PTypeInfo(TypeInfo(T)).Kind = tkClass then
    PObject(@AObject)^.Free;
end;

class function TRttiExplorer.EntityChanged(AEntity1, AEntity2: TObject): Boolean;
var
  LChangedMembers: IList<ColumnAttribute>;
begin
  LChangedMembers := GetChangedMembers(AEntity1, AEntity2);
  Result := (LChangedMembers.Count > 0);
end;

class function TRttiExplorer.GetAsRecord(ARttiObject: TRttiNamedObject): TRttiRecordType;
begin
  Result := nil;
  if ARttiObject is TRttiProperty then
    Result := TRttiProperty(ARttiObject).PropertyType.AsRecord
  else if ARttiObject is TRttiField then
    Result := TRttiField(ARttiObject).FieldType.AsRecord;
end;

class function TRttiExplorer.GetAssociations(AClass: TClass): IList<Association>;
begin
  Result := GetClassMembers<Association>(AClass);
end;

class function TRttiExplorer.GetAttributeOfClass(ARttiObject: TRttiObject;
  AClass: TClass): TCustomAttribute;
begin
  for Result in ARttiObject.GetAttributes do
  begin
    if Result.InheritsFrom(AClass) then
    begin
      Exit;
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetAutoGeneratedColumnMemberName(AClass: TClass): string;
var
  LIds: IList<AutoGenerated>;
begin
  Result := '';

  LIds := GetClassMembers<AutoGenerated>(AClass);
  if LIds.Count > 0 then
  begin
    Result := LIds.First.ClassMemberName;
  end;
end;

class function TRttiExplorer.GetChangedMembers(AOriginalObj, ADirtyObj: TObject): IList<ColumnAttribute>;
begin
  Result := TCollections.CreateList<ColumnAttribute>;
  GetChangedMembers(AOriginalObj, ADirtyObj, Result);
end;

class procedure TRttiExplorer.GetChangedMembers(AOriginalObj, ADirtyObj: TObject; AList: IList<ColumnAttribute>);
var
  LRttiType: TRttiType;
  LMember: TRttiMember;
  LOriginalValue, LDirtyValue: TValue;
  LCol: ColumnAttribute;
  LColumns: IList<ColumnAttribute>;
begin
  Assert(AOriginalObj.ClassType = ADirtyObj.ClassType);
  LRttiType := FRttiCache.GetType(AOriginalObj.ClassInfo);
  AList.Clear;

  LColumns := GetColumns(AOriginalObj.ClassType);
  for LCol in LColumns do
  begin
    if not LCol.IsDiscriminator then
    begin

      case LCol.MemberType of
        mtField:    LMember := FRttiCache.GetField(LRttiType.AsInstance.MetaclassType, LCol.ClassMemberName); // LRttiType.GetField(LCol.ClassMemberName);
        mtProperty: LMember := FRttiCache.GetProperty(LRttiType.AsInstance.MetaclassType, LCol.ClassMemberName); // LRttiType.GetProperty(LCol.ClassMemberName);
      else
        LMember := nil;
      end;

      if not Assigned(LMember) then
        raise EUnknownMember.Create('Unknown column member: ' + LCol.ClassMemberName);

      LOriginalValue := GetMemberValue(AOriginalObj, LMember);
      LDirtyValue := GetMemberValue(ADirtyObj, LMember);

      if not Spring.Persistence.Core.Reflection.SameValue(LOriginalValue, LDirtyValue) then
        AList.Add(LCol);
    end;
  end;
end;

class function TRttiExplorer.GetClassAttribute<T>(AClass: TClass; ARecursive: Boolean): T;
var
  LAttr: TCustomAttribute;
  LTypeInfo: Pointer;
  LType: TRttiType;
  LClass: TClass;
begin
  LTypeInfo := TypeInfo(T);
  LClass := AClass;
  repeat
    LType := FRttiCache.GetType(LClass);
    for LAttr in LType.GetAttributes do
    begin
      if (LAttr.ClassInfo = LTypeInfo) then
      begin
        Exit(T(LAttr));
      end;
    end;

    if ARecursive then
      LClass := LClass.ClassParent
    else
      LClass := nil;
  until (LClass = nil);
  Result := nil;
end;

class function TRttiExplorer.GetClassFromClassInfo(AClassInfo: PTypeInfo): TClass;
var
  LType: TRttiType;
begin
  LType := FRttiCache.GetType(AClassInfo);
  Assert(LType.IsInstance);
  Result := LType.AsInstance.MetaclassType;
end;

class procedure TRttiExplorer.GetClassMembers<T>(AClass: TClass; AList: IList<T>);
var
  LType: TRttiType;
  LField: TRttiField;
  LProp: TRttiProperty;
  LAttr: TCustomAttribute;
  LTypeInfo: Pointer;
begin
  {TODO -oLinas -cGeneral : use FRttiCache for this task, this should increase performance}
  AList.Clear;
  LType := FRttiCache.GetType(AClass);
  LTypeInfo := TypeInfo(T);

  for LAttr in LType.GetAttributes do
  begin
    if LAttr is TORMAttribute then
    begin
      TORMAttribute(LAttr).ClassMemberName := LType.Name;
      TORMAttribute(LAttr).EntityTypeInfo := LType.Handle;
      TORMAttribute(LAttr).MemberType := mtClass;
    end;
  end;

  for LField in LType.GetFields do
  begin
    for LAttr in LField.GetAttributes do
    begin
      if (LTypeInfo = LAttr.ClassInfo) or (InheritsFrom(LAttr.ClassType, LTypeInfo)) then
      begin
        TORMAttribute(LAttr).MemberType := mtField;
        TORMAttribute(LAttr).ClassMemberName := LField.Name;
        TORMAttribute(LAttr).EntityTypeInfo := LType.Handle;
        AList.Add(T(LAttr));
      end;
    end;
  end;

  for LProp in LType.GetProperties do
  begin
    for LAttr in LProp.GetAttributes do
    begin
      if (LTypeInfo = LAttr.ClassInfo) or (InheritsFrom(LAttr.ClassType, LTypeInfo)) then
      begin
        TORMAttribute(LAttr).MemberType := mtProperty;
        TORMAttribute(LAttr).ClassMemberName := LProp.Name;
        TORMAttribute(LAttr).EntityTypeInfo := LType.Handle;
        AList.Add(T(LAttr));
      end;
    end;
  end;
end;

class function TRttiExplorer.GetClassMembers<T>(AClass: TClass): IList<T>;
begin
  Result := TCollections.CreateList<T>;
  GetClassMembers<T>(AClass, Result);
end;

class function TRttiExplorer.GetColumnIsIdentity(AClass: TClass; AColumn: ColumnAttribute): Boolean;
begin
  Result := SameText(GetAutoGeneratedColumnMemberName(AClass), AColumn.ClassMemberName);
end;

class procedure TRttiExplorer.GetColumns(AClass: TClass; AColumns: IList<ColumnAttribute>);
begin
  GetClassMembers<ColumnAttribute>(AClass, AColumns);
end;

class procedure TRttiExplorer.GetDeclaredConstructors(AClass: TClass; AList: IList<TRttiMethod>);
var
  LType: TRttiType;
  LMethod: TRttiMethod;
begin
  LType := FRttiCache.GetType(AClass);
  for LMethod in LType.GetDeclaredMethods do
  begin
    if LMethod.IsConstructor then
    begin
      AList.Add(LMethod);
    end;
  end;
end;

class function TRttiExplorer.GetColumns(AClass: TClass): IList<ColumnAttribute>;
begin
  Result := GetClassMembers<ColumnAttribute>(AClass);
end;

class function TRttiExplorer.TryGetBasicMethod(const AMethodName: string; ATypeInfo: PTypeInfo;
  out AMethod: TRttiMethod): Boolean;
var
  LMethod, LResultMethod: TRttiMethod;
  iParCount, iCurrParCount, iCount: Integer;
  LType: TRttiType;
begin
  Result := False;
  LMethod := nil;
  iParCount := 0;
  iCurrParCount := 0;
  LType := FRttiCache.GetType(ATypeInfo);
  for LResultMethod in LType.GetMethods do
  begin
    if SameText(LResultMethod.Name, AMethodName) then
    begin
      Result := True;
      iCount := Length(LResultMethod.GetParameters);
      if (iCount < iParCount) or (iCount = 0) then
      begin
        AMethod := LResultMethod;
        Exit;
      end
      else
      begin
        if (iCount > iCurrParCount) then
        begin
          Inc(iParCount);
        end;

        iCurrParCount := iCount;
        LMethod := LResultMethod;
      end;
    end;
  end;
  AMethod := LMethod;
end;

class function TRttiExplorer.TryGetMethod(ATypeInfo: PTypeInfo; const AMethodName: string
  ; out AAddMethod: TRttiMethod; AParamCount: Integer): Boolean;
var
  LType: TRttiType;
  LMethod: TRttiMethod;
begin
  LType := FCtx.GetType(ATypeInfo);
  for LMethod in LType.GetMethods do
  begin
    if SameText(LMethod.Name, AMethodName) and (Length(LMethod.GetParameters) = AParamCount) then
    begin
      AAddMethod := LMethod;
      Exit(True);
    end;
  end;
  Result := False;
end;

class function TRttiExplorer.TryGetColumnAsForeignKey(AColumn: ColumnAttribute;
  out AForeignKeyCol: ForeignJoinColumnAttribute): Boolean;
var
  LNamedObject: TRttiNamedObject;
  LCustomAttribute: TCustomAttribute;
begin
  Result := False;
  LCustomAttribute := nil;

  LNamedObject := FRttiCache.GetNamedObject(AColumn.BaseEntityClass, AColumn.ClassMemberName);
  if Assigned(LNamedObject) then
  begin
    LCustomAttribute := GetAttributeOfClass(LNamedObject, ForeignJoinColumnAttribute);
    Result := Assigned(LCustomAttribute);
  end;

  if Result then
    AForeignKeyCol := LCustomAttribute as ForeignJoinColumnAttribute;
end;

class function TRttiExplorer.TryGetColumnByMemberName(AClass: TClass;
  const AClassMemberName: string; out AColumn: ColumnAttribute): Boolean;
begin
  AColumn := TEntityCache.Get(AClass).ColumnByMemberName(AClassMemberName);
  Result := Assigned(AColumn);
end;

class function TRttiExplorer.TryGetEntityClass(ATypeInfo: PTypeInfo; out AClass: TClass): Boolean;
var
  LRttiType: TRttiType;
begin
  Result := False;
  LRttiType := GetEntityRttiType(ATypeInfo);
  if Assigned(LRttiType) then
  begin
    AClass := LRttiType.AsInstance.MetaclassType;
    Result := True;
  end;
end;

class function TRttiExplorer.TryGetEntityClass<T>(out AClass: TClass): Boolean;
begin
  Result := TryGetEntityClass(TypeInfo(T), AClass);
end;

class function TRttiExplorer.TryGetPrimaryKeyValue(AColumns: IList<ColumnAttribute>;
  AResultset: IDBResultset; out AValue: TValue; out AColumn: ColumnAttribute): Boolean;
var
  LCol: ColumnAttribute;
  LVal: Variant;
begin
  for LCol in AColumns do
  begin
    if cpPrimaryKey in LCol.Properties then
    begin
      LVal := AResultset.GetFieldValue(LCol.Name);
      AValue := TUtils.FromVariant(LVal);
      AColumn := LCol;
      Exit(True);
    end;
  end;
  Result := False;
end;

class function TRttiExplorer.GetEntities: IList<TClass>;
var
  LType: TRttiType;
  LClass: TClass;
  LEntity: EntityAttribute;
begin
  Result := TCollections.CreateList<TClass>;

  for LType in FCtx.GetTypes do
  begin
    if LType.IsInstance then
    begin
      LClass := LType.AsInstance.MetaclassType;
      LEntity := GetClassAttribute<EntityAttribute>(LClass);
      if Assigned(LEntity) then
      begin
        Result.Add(LClass);
      end;
    end;
  end;
end;

class function TRttiExplorer.GetEntityRttiType(ATypeInfo: PTypeInfo): TRttiType;
var
  LRttiType: TRttiType;
  LCurrType: TRttiType;
begin
  LRttiType := FRttiCache.GetType(ATypeInfo);
  for LCurrType in LRttiType.GetGenericArguments do
  begin
    if LCurrType.IsInstance then
    begin
      if (TEntityCache.Get(LCurrType.AsInstance.MetaclassType) <> nil) then
        Exit(LCurrType);
    end;
  end;

  if LRttiType.IsInstance then
  begin
    if (TEntityCache.Get(LRttiType.AsInstance.MetaclassType).EntityTable <> nil) then
      Exit(LRttiType);
  end;
  Result := nil;
end;

class function TRttiExplorer.GetEntityRttiType<T>(): TRttiType;
begin
  Result := GetEntityRttiType(TypeInfo(T));
end;

class function TRttiExplorer.GetForeignKeyColumn(AClass: TClass;
  const ABaseTablePrimaryKeyColumn: ColumnAttribute): ForeignJoinColumnAttribute;
var
  LForeignCol: ForeignJoinColumnAttribute;
begin
  for LForeignCol in TEntityCache.Get(AClass).ForeignColumns do
  begin
    if SameText(ABaseTablePrimaryKeyColumn.ClassMemberName, LForeignCol.ReferencedColumnName) then
    begin
      Exit(LForeignCol);
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetLastGenericArgumentType(ATypeInfo: PTypeInfo): TRttiType;
var
  LArgs: TArray<TRttiType>;
begin
  Result := TRttiContext.Create.GetType(ATypeInfo);
  LArgs := Result.GetGenericArguments;
  if Length(LArgs) > 0 then
  begin
    Result := LArgs[High(LArgs)];
  end;
end;

class function TRttiExplorer.GetPrimaryKeyColumn(AClass: TClass): ColumnAttribute;
var
  LColumns: IList<ColumnAttribute>;
  LCol: ColumnAttribute;
begin
  LColumns := GetColumns(AClass);
  for LCol in LColumns do
  begin
    if (cpPrimaryKey in LCol.Properties) then
    begin
      Exit(LCol);
    end;
  end;
  Result := nil;
end;

class function TRttiExplorer.GetPrimaryKeyColumnMemberName(AClass: TClass): string;
var
  LCol: ColumnAttribute;
begin
  Result := '';

  LCol := GetPrimaryKeyColumn(AClass);
  if Assigned(LCol) then
  begin
    Result := LCol.ClassMemberName;
  end;
end;

class function TRttiExplorer.GetPrimaryKeyColumnName(AClass: TClass): string;
var
  LCol: ColumnAttribute;
begin
  Result := '';

  LCol := GetPrimaryKeyColumn(AClass);
  if Assigned(LCol) then
  begin
    Result := LCol.Name;
  end;
end;

class function TRttiExplorer.GetPrimaryKeyValue(AEntity: TObject): TValue;
begin
  Result := GetMemberValue(AEntity, GetPrimaryKeyColumnMemberName(AEntity.ClassType));
end;

class function TRttiExplorer.GetQueryTextFromMethod(
  AMethod: TRttiMethod): string;
var
  LAttr: TCustomAttribute;
  LQueryAttribute: QueryAttribute;
begin
  Result := '';
  for LAttr in AMethod.GetAttributes do
  begin
    if LAttr is QueryAttribute then
    begin
      LQueryAttribute := QueryAttribute(LAttr);
      Result := LQueryAttribute.QueryText;
      Exit;
    end;
  end;
end;

class function TRttiExplorer.GetRawPointer(const AInstance: TValue): Pointer;
begin
  if AInstance.IsObject then
    Result := AInstance.AsObject
  else
    Result := AInstance.GetReferenceToRawData;
end;

class function TRttiExplorer.GetRelationsOf(AEntity: TObject): IList<TObject>;
var
  LType: TRttiType;
  LField: TRttiField;
  LProperty: TRttiProperty;
  LEntities: IList<TObject>;
begin
  Result := TCollections.CreateList<TObject>;
  //look for OneToMany or ManyToOne attributes
  LType := FRttiCache.GetType(AEntity.ClassType);
  for LField in LType.GetFields do
  begin
    if (LField.HasAttributeOfType<ManyValuedAssociation>) then
    begin
      LEntities := GetSubEntityFromMemberDeep(AEntity, LField);
      if LEntities.Count > 0 then
        Result.AddRange(LEntities);
    end;
  end;

  for LProperty in LType.GetProperties do
  begin
    if (LProperty.HasAttributeOfType<ManyValuedAssociation>) then
    begin
      LEntities := GetSubEntityFromMemberDeep(AEntity, LProperty);
      if LEntities.Count > 0 then
        Result.AddRange(LEntities);
    end;
  end;
end;

class function TRttiExplorer.GetRttiType(AEntity: TClass): TRttiType;
begin
  Result := TRttiContext.Create.GetType(AEntity);
end;

class function TRttiExplorer.GetMemberTypeInfo(AClass: TClass; const AMemberName: string): PTypeInfo;
var
  LNamedObj: TRttiNamedObject;
begin
  Result := nil;

  LNamedObj := FRttiCache.GetNamedObject(AClass, AMemberName);
  if Assigned(LNamedObj) then
  begin
    Result := LNamedObj.GetTypeInfo;
  end;
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMember: TRttiNamedObject): TValue;
begin
  if AMember is TRttiField then
  begin
    Result := TRttiField(AMember).GetValue(AEntity);
  end
  else if AMember is TRttiProperty then
  begin
    Result := TRttiProperty(AMember).GetValue(AEntity);
  end
  else
  begin
    Result := TValue.Empty;
  end;
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMemberName: string): TValue;
var
  LMember: TRttiNamedObject;
begin
  Result := GetMemberValue(AEntity, AMemberName, LMember);
end;

class function TRttiExplorer.GetMemberValue(AEntity: TObject; const AMembername: string;
  out ARttiMember: TRttiNamedObject): TValue;
begin
  ARttiMember := FRttiCache.GetNamedObject(AEntity.ClassType, AMembername);
  Result := GetMemberValue(AEntity, ARttiMember);
end;

class function TRttiExplorer.GetMemberValueDeep(const AInitialValue: TValue;
  ARttiType: TRttiType): TValue;
begin
  Result := AInitialValue;
  if TUtils.IsNullableType(Result.TypeInfo) then
  begin
    if not TUtils.TryGetNullableTypeValue(AInitialValue, Result) then
      Result := TValue.Empty;
  end
  else if TUtils.IsLazyType(Result.TypeInfo) then
  begin
    if not TUtils.TryGetLazyTypeValue(AInitialValue, Result) then
      Result := TValue.Empty;
  end; 
end;

class function TRttiExplorer.GetMemberValueDeep(AEntity: TObject;
  const AMemberName: string): TValue;
var
  LMember: TRttiNamedObject;
begin
  Result := GetMemberValue(AEntity, AMemberName, LMember);

  if Result.IsEmpty then
    Exit;

  Result := GetMemberValueDeep(Result, LMember.GetType);
end;

class function TRttiExplorer.GetMethodSignature(AMethod: TRttiMethod): string;
begin
  Result := AMethod.ToString;
end;

class function TRttiExplorer.GetMethodWithLessParameters(AList: IList<TRttiMethod>): TRttiMethod;
var
  i, iParams, iParamsOld, ix: Integer;
begin
  Assert(AList.Count > 0);
  ix := 0;
  iParamsOld := Length(AList[0].GetParameters);
  for i := 1 to AList.Count - 1 do
  begin
    iParams := Length(AList[i].GetParameters);
    if iParams < iParamsOld then
    begin
      iParamsOld := iParams;
      ix := i;
    end;
  end;

  Result := AList[ix];
end;

class function TRttiExplorer.GetNamedObject(AClass: TClass;
  const APropertyName: string): TRttiNamedObject;
var
  LType: TRttiType;
begin
  LType := FCtx.GetType(AClass);
  Result := LType.GetField(APropertyName);
  if not Assigned(Result) then
    Result := LType.GetProperty(APropertyName);
end;

class function TRttiExplorer.HasInstanceField(AClass: TClass): Boolean;
var
  LField: TRttiField;
  LProp: TRttiProperty;
begin
  //enumerate fields
  for LField in FCtx.GetType(AClass).GetFields do
  begin
    if (LField.FieldType.IsInstance) then
    begin
      Exit(True);
    end;
  end;

  for LProp in FCtx.GetType(AClass).GetProperties do
  begin
    if (LProp.PropertyType.IsInstance) then
    begin
      Exit(True);
    end;
  end;

  Result := False;
end;

class function TRttiExplorer.GetSequence(AClass: TClass): SequenceAttribute;
begin
  Result := GetClassAttribute<SequenceAttribute>(AClass, True);
end;

class function TRttiExplorer.GetSubEntityFromMemberDeep(AEntity: TObject; ARttiMember: TRttiNamedObject): IList<TObject>;
var
  LMemberValue: TValue;
  LDeepValue: TValue;
  LEnumMethod: TRttiMethod;
  LCollectionAdapter: ICollectionAdapter<TObject>;
  LCurrent: TObject;
begin
  Result := TCollections.CreateList<TObject>;

  LMemberValue := GetMemberValue(AEntity, ARttiMember);
  if LMemberValue.IsEmpty then
    Exit;
    
  LDeepValue := GetMemberValueDeep(LMemberValue, ARttiMember.GetType);
  if LDeepValue.IsEmpty then
    Exit;
  
  if TUtils.IsEnumerable(LDeepValue.TypeInfo, LEnumMethod) then
  begin
    LCollectionAdapter := TCollectionAdapterResolver.Resolve<TObject>(LDeepValue);

    for LCurrent in LCollectionAdapter do
    begin
      Result.Add(LCurrent);
    end;                       
    LDeepValue := TValue.Empty; 
  end;

  if (LDeepValue.IsObject) and (LDeepValue.AsObject <> nil) then
    Result.Add(LDeepValue.AsObject);
end;

class function TRttiExplorer.GetTable(AClassInfo: PTypeInfo): TableAttribute;
var
  LClass: TClass;
begin
  LClass := GetClassFromClassInfo(AClassInfo);
  Result := GetTable(LClass);
end;

class function TRttiExplorer.GetTable(AClass: TClass): TableAttribute;
begin
  Result := GetClassAttribute<TableAttribute>(AClass, True);
end;

class function TRttiExplorer.GetUniqueConstraints(AClass: TClass): IList<UniqueConstraint>;
begin
  Result := GetClassMembers<UniqueConstraint>(AClass);
end;

class function TRttiExplorer.HasColumns(AClass: TClass): Boolean;
var
  LList: IList<ColumnAttribute>;
begin
  LList := GetColumns(AClass);
  Result := LList.Count > 0;
end;

class function TRttiExplorer.HasSequence(AClass: TClass): Boolean;
begin
  Result := (GetSequence(AClass) <> System.Default(SequenceAttribute) );
end;

class function TRttiExplorer.InheritsFrom(AObjectInfo: TClass;
  AFromObjectInfo: PTypeInfo): Boolean;
var
  LClass: TClass;
begin
  if Assigned(AObjectInfo) then
  begin
    Result := AObjectInfo.ClassInfo = AFromObjectInfo;
  end
  else
  begin
    Exit(False);
  end;
  if not Result then
  begin
    LClass := AObjectInfo.ClassParent;
    if Assigned(LClass) then
      Result := InheritsFrom(LClass, AFromObjectInfo);
  end;
end;

class procedure TRttiExplorer.SetMemberValue(AManager: TObject; AEntity: TObject; const AMemberColumn: ColumnAttribute;
  const AValue: TValue);
begin
  Assert(Assigned(AMemberColumn));
  SetMemberValue(AManager, AEntity, AMemberColumn.ClassMemberName, AValue);
end;

class procedure TRttiExplorer.SetMemberValue(AManager: TObject; AEntity: TObject; const AMemberName: string; const AValue: TValue);
var
  LValue: TValue;
  LNamedObject: TRttiNamedObject;
begin
  LValue := TValue.Empty;

  LNamedObject := FRttiCache.GetNamedObject(AEntity.ClassType, AMemberName);
  if Assigned(LNamedObject) then
  begin
    if TUtils.TryConvert(AValue, AManager, LNamedObject, AEntity, LValue) then
    begin
      SetValue(AEntity, LNamedObject, LValue);
    end;
  end;
end;

class procedure TRttiExplorer.SetMemberValueSimple(AEntity: TObject; const AMemberName: string; const AValue: TValue);
var
  LNamedObject: TRttiNamedObject;
begin
  LNamedObject := FRttiCache.GetNamedObject(AEntity.ClassType, AMemberName);
  if Assigned(LNamedObject) then
  begin
    SetValue(AEntity, LNamedObject, AValue);
  end;
end;

class procedure TRttiExplorer.SetValue(AInstance: Pointer; ANamedObject: TRttiNamedObject; const AValue: TValue);

  procedure SetInternalValue();
  begin
    if ANamedObject.isField then
      ANamedObject.AsField.SetValue(AInstance, AValue)
    else
    begin
      ANamedObject.AsProperty.SetValue(AInstance, AValue);
    end;
  end;

begin
  if ANamedObject is TRttiInstanceProperty then
  begin
    case AValue.Kind of
      tkInteger : SetOrdProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsInteger);
      tkFloat: SetFloatProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsExtended);
      tkString, tkLString: SetAnsiStrProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsType<AnsiString>);
      tkClass: SetObjectProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsObject) ;
      tkVariant: SetVariantProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsVariant);
      tkInterface: SetInterfaceProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsInterface);
      tkInt64: SetInt64Prop(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsInt64);
      tkDynArray: SetDynArrayProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.GetReferenceToRawData);
      tkUString, tkWString: SetStrProp(TObject(AInstance), TRttiInstanceProperty(ANamedObject).PropInfo, AValue.AsString)
      else
      begin
        SetInternalValue();
      end;
    end;
  end
  else
  begin
    SetInternalValue();
  end;
end;

{ TRttiCache }

procedure TRttiCache.Clear;
begin
  FFields.Clear;
  FProperties.Clear;
  FTypes.Clear;
  FTypeFields.Clear;
end;

constructor TRttiCache.Create;
begin
  inherited Create;
  FFields := TCollections.CreateDictionary<string, TRttiField>();
  FProperties := TCollections.CreateDictionary<string,TRttiProperty>();
  FTypes := TCollections.CreateDictionary<PTypeInfo, TRttiType>();
  FTypeFields := TCollections.CreateDictionary<PTypeInfo,IList<TRttiField>>;
end;

destructor TRttiCache.Destroy;
begin
  inherited Destroy;
end;

function TRttiCache.GetField(AClass: TClass; const AFieldName: string): TRttiField;
begin
  if not FFields.TryGetValue(GetKey(AClass, AFieldName), Result) then
    Result := nil;
end;

function TRttiCache.GetFieldsOfType(ATypeInfo: PTypeInfo): IList<TRttiField>;
begin
  if not FTypeFields.TryGetValue(ATypeInfo, Result) then
    Result := TCollections.CreateList<TRttiField>;
end;

function TRttiCache.GetKey(AClass: TClass; const AName: string): string;
begin
  Result := UpperCase(AClass.UnitName + '.' + AClass.ClassName + '_' + AName);
end;

function TRttiCache.GetNamedObject(AClass: TClass; const APropertyName: string): TRttiNamedObject;
begin
  Result := GetField(AClass, APropertyName);
  if Result = nil then
    Result := GetProperty(AClass, APropertyName);
  if not Assigned(Result) then
  begin
    Result := TRttiExplorer.GetNamedObject(AClass, APropertyName);
  end;
end;

function TRttiCache.GetProperty(AClass: TClass; const APropertyName: string): TRttiProperty;
begin
  if not FProperties.TryGetValue(GetKey(AClass, APropertyName), Result) then
    Result := nil;
end;

function TRttiCache.GetType(AClass: TClass): TRttiType;
begin
  Result := nil;
  if Assigned(AClass) then
  begin
    Result := GetType(AClass.ClassInfo);
    if (Result = nil) then
    begin
      Result := FCtx.GetType(AClass);
    end;
  end;
end;

function TRttiCache.GetType(ATypeInfo: PTypeInfo): TRttiType;
begin
  if not FTypes.TryGetValue(ATypeInfo, Result) then
    Result := nil;
end;

procedure TRttiCache.RebuildCache;
var
  LType: TRttiType;
  LClass: TClass;
  LProp: TRttiProperty;
  LField: TRttiField;
  LFields: IList<TRttiField>;
begin
  Clear;

  for LType in FCtx.GetTypes do
  begin
    FTypes.Add(LType.Handle, LType);

    if LType.IsInstance then
    begin
      LClass := LType.AsInstance.MetaclassType;

      if TRttiExplorer.HasColumns(LClass) then
      begin
        LFields := TCollections.CreateList<TRttiField>;
        for LField in LType.GetFields do
        begin
          FFields.Add(GetKey(LClass, LField.Name), LField);
          LFields.Add(LField);
        end;
        FTypeFields.Add(LType.Handle, LFields);

        for LProp in LType.GetProperties do
        begin
          FProperties.Add(GetKey(LClass, LProp.Name), LProp);
        end;
      end;
    end;
  end;
end;



end.
